{"./":{"url":"./","title":"Welcome","keywords":"","body":" Welcome 平时收集的资源挺杂，用时得挨个找，干脆，写个网站整理出来。 如果有需要，可以联系我获取，当然，部分资源需要付费，介意勿扰。 申明一点，本站资源旨在学习，不做商用，后果自负。 远离黄赌毒，拒绝灰黑产。 一期一会 一期一会源于日本茶道，意思是在茶会时领悟到这次相会无法重来，一辈子只有一次的相会。 在茶道以外，这个意义可推而广之，指一生一次的机会，当下的时光不会再来，须珍重之。 联系 请通过微信与我联系，添加方式如下： 微信号(备注网站)：recently0216 微信二维码(备注网站)： "},"invest/tool.html":{"url":"invest/tool.html","title":"经济指标查询链接","keywords":"","body":"经济指标查询链接 数据类 CPI指数 - 居民消费价格指数 PPI指数 - 工业品出厂价格指数 GDP指数 - 国内生产总值 PMI指数 - 采购经理人指数 存款准备金率 货币供应量（M1.M2.M0） 工业增加值 银行间拆借利率（Shibor） 新增信贷数据 中国10年期国债收益率 人民币兑美元 纽约黄金 螺纹钢 伦铜 布伦特原油 铁矿石 路透CRB商品指数 波罗的海BDI指数 美元指数 中证转债 企债指数 天天基金网 中证指数官网 智投星 - DIY定投策略 理杏仁 - 指数基金估值查询 集思录- 中国专业的低风险投资工具型社区 看财报 巨潮资讯 - 中国证监会指定的信息披露网站 果仁网 - 适合入门级的量化投资者 东方财富网 中国理财网 - 银行理财产品查询 天眼查 金银比 国家统计局 上海银行间同业拆放利率 全球经济数据 应用类 东方财富 通达信 英为行情 万得股票 天天基金 晨星网 "},"invest/morningstar.html":{"url":"invest/morningstar.html","title":"如何利用晨星网选基金","keywords":"","body":"如何利用晨星网选基金 基金投资是一个需要足够耐心的工作，很可能多年不涨，但如果十年如一日坚持下来，年化10%的收益率还是很容易实现的，做的好一些，15~20%的年化收益率也是有可能的。 中国晨星基金网 上有很多工具和指标，可以对我们心仪的基金进行分析，然后选择后进行投资。 1、平均回报：该指标是一个推荐值，是将现有收益推算成年化收益进行比较，指标值越大越好。 2、标准差：是基金增长率的波动情况，标准差越大说明波动越大，短期风险也就越大。 3、夏普比率：该指标综合了收益和风险的系数，夏普比率大于1就说明收益大于风险，而小于1则表明收益小于风险；不过这个指标也是动态的，基金表现好的时候，夏普比率就大，而基金表现欠佳的时候，夏普比率就小，所以它不适用于自己跟自己比较，而适用于同一时间几只基金的横向比较。 4、阿尔法系数：该指标表示的是基金有多大概率能跑赢大盘，其指标值当然是越大越好。 5、贝塔系数：是对于大盘的波动情况，如果是指数基金，其值基本就是1，如果比1大，那表明这只基金比大盘波动还大，而比1小，说明波动小。 6、R平方：该指标说明的是该基金跟大盘的相关性，如果值是1，表示跟大盘完全相关，所以这个指标值当然越小越好，越小的话说明越容易走出独立行情。 总结一下，如果一只基金所有指标都大，说明处于牛市之中，这个基金非常激进，务必要小心到顶之后的大幅回撤。如果一只基金所有指标都小，说明一直在稳定地赔钱。 另外晨星基金网上，还提供了一个工具叫做风格箱，这个东西就是告诉你，你买的基金属于什么风格。如何构建一个投资组合，这就涉及到风格平衡，不能光买大盘价值型的，也不能光买大盘成长型的，要把他们组合在一起。如果你希望获得更高收益，就还要配置中小盘成长型的基金，比如国投瑞银新兴产业、中邮战略新兴产业，都属于中小盘成长，属于很激进类型。如果你要获得年化15%以上的收益，就得指着这种基金了。大盘价值型基金很难跑出这个成绩。 当然也没必要去选择中小盘的价值型基金，这就比较拧巴了，他也是四不像。所以如果你如果要想通过主动型基金构筑一个选择，那么可以考虑上面的例子，大盘价值，大盘平衡，大盘成长各选一只，然后再选一只中小盘成长足以。 "},"python/environment/python.html":{"url":"python/environment/python.html","title":"Python 3.7 安装","keywords":"","body":"Python 3.7 安装 Mac电脑本身自带Python 2.x版本，而Python 3.x版本与Python 2.x版本本身差异较大，作为开发还是需要安装较新的版本。 下载 官网下载 安装 完成安装文件下载后，直接按照安装提示“下一步”即可。 验证 在终端输入相应指令查看 Python 是否安装成功： yvesdeMacBook-Air:Resous_archive yves$ python3 -V Python 3.7.7 同时，可以通过下面的命令查看 Python 自带的包安装管理工具： yvesdeMacBook-Air:Resous_archive yves$ pip3 --version pip 19.2.3 from /Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pip (python 3.7) "},"python/environment/mysql.html":{"url":"python/environment/mysql.html","title":"MySQL 数据库安装","keywords":"","body":"MySQL 数据库安装 下载 官网下载 安装 完成安装文件下载后，直接按照安装提示“下一步”，中途需要输入管理员密码。 登录 第一种方式是直接在电脑的程序中找到 MySQL 并将其启动；第二种则是通过命令终端进行启动，需要在环境变量中添加： PATH=\"$PATH\":/usr/local/mysql/bin 完成添加，刷新环境变量后，输入一下命令进入 MySQL 数据库： yvesdeMacBook-Air:Resous_archive yves$ mysql -u root -p Enter password: "},"python/environment/pycharm.html":{"url":"python/environment/pycharm.html","title":"PyCharm 集成开发环境安装","keywords":"","body":"PyCharm 集成开发环境安装 下载 官网下载 安装 完成安装文件下载后，直接按照安装提示“下一步”即可。 "},"python/environment/pipenv.html":{"url":"python/environment/pipenv.html","title":"Pipenv 包管理工具安装","keywords":"","body":"Pipenv 包管理工具安装 pipenv 是什么 pipenv 是 python 官方推荐的包管理工具，集成了 virtualenv、pyenv 和 pip 三者的功能于一身，类似于 php 中的 composer。 我们知道，为了方便管理 python 的虚拟环境和库，通常使用较多的是 virtualenv 、pyenv 和 pip，但是他们不够好用或者说不够偷懒。于是 requests 的作者 Kenneth Reitz 开发了用于创建和管理 python 虚拟环境的工具 —- pipenv。 它能够自动为项目创建和管理虚拟环境，从 Pipfile 文件中添加或者删除包，同时生成 Pipfile.lock 文件来锁定安装包的版本和依赖信息，避免构建错误。 pipenv 主要解决了以下问题： 不用再单独使用 virtualenv、pyenv 和 pip 了，现在它们结合到了一起。 不用再维护 requirement.txt 了，使用 Pipfile 和 Pipfile.lock 来代替。 可以在开发环境使用多个 python 版本。 在安装的 pyenv 条件下，可以自动安装需要的 python 版本。 安全，广泛地使用 Hash 校验，能够自动曝露安全漏洞。 随时查看图形化的依赖关系。 安装 pipenv 使用 pip 安装 $ pip install --user pipenv 这个命令在用户级别（非系统全局）下安装 pipenv。如果安装后 shell 提示找不到 pipenv 命令，你需要添加当前 Python 用户主目录的 bin 目录到 PATH 环境变量。 碰到问题 显示 “Pipenv: Command Not Found” 错误时，按如下操作进行： # 环境变量中添加如下配置 PYTHON_BIN_PATH=\"$(python3 -m site --user-base)/bin\" PATH=\"$PATH:$PYTHON_BIN_PATH\" 使用 brew 安装 Mac 下使用 brew 安装软件应该是最方便的了，推荐使用： brew install pipenv 升级 pipenv： brew upgrade pipenv 常用命令 pipenv 具有的选项： Options: --where Output project home information. --venv Output virtualenv information. --py Output Python interpreter information. --envs Output Environment Variable options. --rm Remove the virtualenv. --bare Minimal output. --completion Output completion (to be eval'd). --man Display manpage. --support Output diagnostic information for use in GitHub issues. --site-packages Enable site-packages for the virtualenv. [env var: PIPENV_SITE_PACKAGES] --python TEXT Specify which version of Python virtualenv should use. --three / --two Use Python 3/2 when creating virtualenv. --clear Clears caches (pipenv, pip, and pip-tools). [env var: PIPENV_CLEAR] -v, --verbose Verbose mode. --pypi-mirror TEXT Specify a PyPI mirror. --version Show the version and exit. -h, --help Show this message and exit. pipenv 可使用的命令参数： Commands: check Checks for security vulnerabilities and against PEP 508 markers provided in Pipfile. clean Uninstalls all packages not specified in Pipfile.lock. graph Displays currently-installed dependency graph information. install Installs provided packages and adds them to Pipfile, or (if no packages are given), installs all packages from Pipfile. lock Generates Pipfile.lock. open View a given module in your editor. run Spawns a command installed into the virtualenv. shell Spawns a shell within the virtualenv. sync Installs all packages specified in Pipfile.lock. uninstall Un-installs a provided package and removes it from Pipfile. update Runs lock, then sync. 一些例子： Usage Examples: Create a new project using Python 3.7, specifically: $ pipenv --python 3.7 Remove project virtualenv (inferred from current directory): $ pipenv --rm Install all dependencies for a project (including dev): $ pipenv install --dev Create a lockfile containing pre-releases: $ pipenv lock --pre Show a graph of your installed dependencies: $ pipenv graph Check your installed dependencies for security vulnerabilities: $ pipenv check Install a local setup.py into your virtual environment/Pipfile: $ pipenv install -e . Use a lower-level pip command: $ pipenv run pip freeze pipenv 使用过程 创建环境，安装指定 python 的版本信息： yvesdeMacBook-Air:Python yves$ mkdir GeneralCrawler yvesdeMacBook-Air:Python yves$ cd GeneralCrawler yvesdeMacBook-Air:GeneralCrawler yves$ pipenv install 如果指定了 --two 或者 --three 选项参数，则会使用 python2 或者 python3 的版本安装，否则将使用默认的 python 版本来安装。当然也可以指定准确的版本信息： yvesdeMacBook-Air:GeneralCrawler yves$ pipenv install --two yvesdeMacBook-Air:GeneralCrawler yves$ pipenv install --three yvesdeMacBook-Air:GeneralCrawler yves$ pipenv install --python 3.6.4 pipenv 会自动扫描系统寻找合适的版本信息，如果找不到的话，同时又安装了 pyenv 的话，则会自动调用 pyenv 下载对应版本的 python， 否则会报错。 这时候在当前 GeneralCrawler 环境下生成 Pipfile 和 Pipfile.lock 两个环境初始化文件。 进入|退出环境： 进入环境： yvesdeMacBook-Air:GeneralCrawler yves$ pipenv shell 退出环境： (GeneralCrawler) bash-3.2$ exit 安装第三方包： 在安装第三方包之前，我们可以修改镜像源(建议使用清华源：https://pypi.tuna.tsinghua.edu.cn/simple )来加快下载速度： (GeneralCrawler) bash-3.2$ vim Pipfile url = \"https://pypi.tuna.tsinghua.edu.cn/simple\" 此时我们测试安装 requests 包： (GeneralCrawler) bash-3.2$ pipenv install requests 此时，Pipfile 里有最新安装的包文件的信息，如名称、版本等。用来在重新安装项目依赖或与他人共享项目时，你可以用 Pipfile 来跟踪项目依赖。 Pipfile 是用来替代原来的 requirements.txt 的，内容类似下面这样。source 部分用来设置仓库地址，packages 部分用来指定项目依赖的包，dev-packages 部分用来指定开发环境需要的包，这样分开便于管理。 [[source]] name = \"pypi\" url = \"https://pypi.tuna.tsinghua.edu.cn/simple\" verify_ssl = true [dev-packages] [packages] requests = \"*\" [requires] python_version = \"3.6\" Pipfile.lock 则包含你的系统信息，所有已安装包的依赖包及其版本信息，以及所有安装包及其依赖包的 Hash 校验信息。 { \"_meta\": { \"hash\": { \"sha256\": \"223fe2288079b4bdf4932ad9f98e6e26b68e9468f2b83dff8dfa78a36cef768b\" }, \"pipfile-spec\": 6, \"requires\": { \"python_version\": \"3.6\" }, \"sources\": [ { \"name\": \"pypi\", \"url\": \"https://pypi.tuna.tsinghua.edu.cn/simple\", \"verify_ssl\": true } ] }, \"default\": { \"certifi\": { \"hashes\": [ \"sha256:017c25db2a153ce562900032d5bc68e9f191e44e9a0f762f373977de9df1fbb3\", \"sha256:25b64c7da4cd7479594d035c08c2d809eb4aab3a26e5a990ea98cc450c320f1f\" ], \"version\": \"==2019.11.28\" }, \"chardet\": { \"hashes\": [ \"sha256:84ab92ed1c4d4f16916e05906b6b75a6c0fb5db821cc65e70cbd64a3e2a5eaae\", \"sha256:fc323ffcaeaed0e0a02bf4d117757b98aed530d9ed4531e3e15460124c106691\" ], \"version\": \"==3.0.4\" }, \"idna\": { \"hashes\": [ \"sha256:c357b3f628cf53ae2c4c05627ecc484553142ca23264e593d327bcde5e9c3407\", \"sha256:ea8b7f6188e6fa117537c3df7da9fc686d485087abf6ac197f9c46432f7e4a3c\" ], \"version\": \"==2.8\" }, \"requests\": { \"hashes\": [ \"sha256:11e007a8a2aa0323f5a921e9e6a2d7e4e67d9877e85773fba9ba6419025cbeb4\", \"sha256:9cf5292fcd0f598c671cfc1e0d7d1a7f13bb8085e9a590f48c010551dc6c4b31\" ], \"index\": \"pypi\", \"version\": \"==2.22.0\" }, \"urllib3\": { \"hashes\": [ \"sha256:a8a318824cc77d1fd4b2bec2ded92646630d7fe8619497b142c84a9e6f5a7293\", \"sha256:f3c5fd51747d450d4dcf6f923c81f78f811aab8205fda64b0aba34a4e48b0745\" ], \"version\": \"==1.25.7\" } }, \"develop\": {} } 现在安装另一个包，再次查看这两个文件的内容。你会发现 Pipfile 现在包含两个安装包了，Pipfile.lock 也包含了所有已安装包的依赖包及其版本信息，以及所有安装包及其依赖包的 Hash 校验信息。每次你安装新的依赖包，这两个文件都会自动更新。 安装指定版本包： (GeneralCrawler) bash-3.2$ pipenv install requests==2.22.0 安装开发环境下的包： 加 --dev 表示包括 Pipfile 的 dev-packages 中的依赖。 (GeneralCrawler) bash-3.2$ pipenv install requests==2.22.0 --dev 卸载第三方包： (GeneralCrawler) bash-3.2$ pipenv uninstall requests 更新安装包： (GeneralCrawler) bash-3.2$ pipenv update requests (GeneralCrawler) bash-3.2$ pipenv update // 更新所有包，会删除所有软件包然后重新安装最新的版本 查看虚拟环境目录： (GeneralCrawler) bash-3.2$ pipenv --venv /Users/yves/.local/share/virtualenvs/GeneralCrawler-flvgS1J0 查看项目根目录： (GeneralCrawler) bash-3.2$ pipenv --where /Users/yves/Documents/GitHub/Python/GeneralCrawler 检查软件包的完整性 pipenv 可以帮你检查已安装的软件包有没有安全漏洞，运行下面的命令： (GeneralCrawler) bash-3.2$ pipenv check Checking PEP 508 requirements… Passed! Checking installed package safety… All good! 查看依赖树 (GeneralCrawler) bash-3.2$ pipenv graph requests==2.22.0 - certifi [required: >=2017.4.17, installed: 2019.11.28] - chardet [required: >=3.0.2,=2.5,=1.21.1,锁定版本 (GeneralCrawler) bash-3.2$ pipenv lock // 更新 lock 文件锁定当前环境的依赖版本 Locking [dev-packages] dependencies… Locking [packages] dependencies… ✔ Success! Updated Pipfile.lock (ef768b)! 环境变量管理 如果你开发调试时需要配一堆环境变量，可以写到 .env 文件中，在 pipenv shell 进入虚拟环境时，它会帮你把这些环境变量加载好，非常方便。 例如写一个 .env 文件： echo \"FOO=hello foo\" > .env 之后 pipenv shell 进入虚拟环境，echo $FOO 就能看环境变量的值 hello foo 已经设置好了。 "},"python/basic/data_type.html":{"url":"python/basic/data_type.html","title":"数据类型与变量","keywords":"","body":"数据类型与变量 计算机程序可以处理不同的数值，除此之外，还可以处理文本、图形、媒体等多种类型的数据，在 Python 编程语言中，能够处理的数据类型主要有：整数、浮点数、字符串、布尔值等等。 数据类型 整数与浮点数 Python 可以处理任意大小的整数与浮点数（小数），在程序中的表示方法和数学上的写法一模一样，例如：120、-78、90.9。 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的，而浮点数运算则可能会有四舍五入的误差。 字符串 字符串是以单引号'或双引号\"括起来的任意文本，比如'abc'，\"xyz\"等等。 布尔值 布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值。 空值 空值是 Python 里一个特殊的值，用 None 表示。None 不能理解为0，因为0是有意义的，而 None 是一个特殊的空值。 常量 常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量： PI = 3.14159265359 变量 变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如： a = 1 t_007 = 'T007' Answer = True 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。 "},"python/basic/data_structure.html":{"url":"python/basic/data_structure.html","title":"数据结构","keywords":"","body":"数据结构 list list 是一种有序的集合，可以随时添加和删除其中的元素。 >>> classmates = ['Michael', 'Bob', 'Tracy'] >>> classmates ['Michael', 'Bob', 'Tracy'] >>> 变量 classmates 就是一个list。用 len() 函数可以获得list元素的个数： >>> len(classmates) 3 用索引来访问list中每一个位置的元素，记得索引是从0开始的： >>> classmates[0] 'Michael' >>> classmates[1] 'Bob' >>> classmates[2] 'Tracy' >>> classmates[3] Traceback (most recent call last): File \"\", line 1, in IndexError: list index out of range 当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。 如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素： >>> classmates[-1] 'Tracy' list是一个可变的有序表，所以，可以往list中追加元素到末尾： >>> classmates.append('Adam') >>> classmates ['Michael', 'Bob', 'Tracy', 'Adam'] 也可以把元素插入到指定的位置，比如索引号为1的位置： >>> classmates.insert(1, 'Jack') >>> classmates ['Michael', 'Jack', 'Bob', 'Tracy', 'Adam'] 要删除list末尾的元素，用pop()方法： >>> classmates.pop() 'Adam' >>> classmates ['Michael', 'Jack', 'Bob', 'Tracy'] 要删除指定位置的元素，用pop(i)方法，其中i是索引位置： >>> classmates.pop(1) 'Jack' >>> classmates ['Michael', 'Bob', 'Tracy'] 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置： >>> classmates[1] = 'Sarah' >>> classmates ['Michael', 'Sarah', 'Tracy'] list里面的元素的数据类型也可以不同，比如： >>> L = ['Apple', 123, True] list元素也可以是另一个list，比如： >>> s = ['python', 'java', ['asp', 'php'], 'scheme'] >>> len(s) 4 要注意s只有4个元素，其中s[2]又是一个list。 tuple tuple和list非常类似，也是一种有序列表叫元组，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字： >>> classmates = ('Michael', 'Bob', 'Tracy') 现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。 不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 dict Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 >>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85} >>> d['Michael'] 95 把数据放入dict的方法，除了初始化时指定外，还可以通过key放入： >>> d['Adam'] = 67 >>> d['Adam'] 67 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉： >>> d['Jack'] = 90 >>> d['Jack'] 90 >>> d['Jack'] = 88 >>> d['Jack'] 88 如果key不存在，dict就会报错： >>> d['Thomas'] Traceback (most recent call last): File \"\", line 1, in KeyError: 'Thomas' 要避免key不存在的错误，有两种办法，一是通过in判断key是否存在： >>> 'Thomas' in d False 二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value： >>> d.get('Thomas') >>> d.get('Thomas', -1) -1 要删除一个key，用pop(key)方法，对应的value也会从dict中删除： >>> d.pop('Bob') 75 >>> d {'Michael': 95, 'Tracy': 85} 请注意，dict内部存放的顺序和key放入的顺序是没有关系的。dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。 set set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。 要创建一个set，需要提供一个list作为输入集合： >>> s = set([1, 2, 3]) >>> s {1, 2, 3} 注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。 重复元素在set中自动被过滤： >>> s = set([1, 1, 2, 2, 3, 3]) >>> s {1, 2, 3} 通过 add(key) 方法可以添加元素到set中，可以重复添加，但不会有效果： >>> s.add(4) >>> s {1, 2, 3, 4} >>> s.add(4) >>> s {1, 2, 3, 4} 通过 remove(key) 方法可以删除元素： >>> s.remove(4) >>> s {1, 2, 3} set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： >>> s1 = set([1, 2, 3]) >>> s2 = set([2, 3, 4]) >>> s1 & s2 {2, 3} >>> s1 | s2 {1, 2, 3, 4} set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。 "},"python/basic/determine_iterate.html":{"url":"python/basic/determine_iterate.html","title":"判断与循环","keywords":"","body":"判断与循环 条件判断 计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。 比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用if语句实现： age = 20 if age >= 18: print('your age is', age) print('adult') 根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做。 也可以给if添加一个else语句，意思是，如果if判断是False，不要执行if的内容，去把else执行了： age = 3 if age >= 18: print('your age is', age) print('adult') else: print('your age is', age) print('teenager') 当然上面的判断是很粗略的，完全可以用elif做更细致的判断： age = 3 if age >= 18: print('adult') elif age >= 6: print('teenager') else: print('kid') if判断条件还可以简写，比如写： if x: print('True') 只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。 循环 Python的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来，看例子： names = ['Michael', 'Bob', 'Tracy'] for name in names: print(name) 执行这段代码，会依次打印names的每一个元素： Michael Bob Tracy 所以for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。 再比如我们想计算1-10的整数之和，可以用一个sum变量做累加： sum = 0 for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]: sum = sum + x print(sum) 如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数： >>> list(range(5)) [0, 1, 2, 3, 4] range(101)就可以生成0-100的整数序列，计算如下： sum = 0 for x in range(101): sum = sum + x print(sum) 第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现： sum = 0 n = 99 while n > 0: sum = sum + n n = n - 2 print(sum) 在循环中，break语句可以提前退出循环。 n = 1 while n 10: # 当n = 11时，条件满足，执行break语句 break # break语句会结束当前循环 print(n) n = n + 1 print('END') 在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。 n = 0 while n "},"python/basic/advanced_features.html":{"url":"python/basic/advanced_features.html","title":"高级特性","keywords":"","body":"高级特性 切片 对取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。 取前3个元素，用一行代码就可以完成切片： >>> L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack'] >>> L[:3] ['Michael', 'Sarah', 'Tracy'] 也可以从索引1开始，取出2个元素出来： >>> L[1:3] ['Sarah', 'Tracy'] 类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片： >>> L[-2:] ['Bob', 'Jack'] >>> L[-2:-1] ['Bob'] 切片操作十分有用: >>> L = list(range(100)) // 创建一个0-99的数列 >>> L [0, 1, 2, 3, ..., 99] >>> L[:10] // 取前10个数 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] >>> L[-10:] // 取后10个数 [90, 91, 92, 93, 94, 95, 96, 97, 98, 99] >>> L[10:20] // 取前11-20个数 [10, 11, 12, 13, 14, 15, 16, 17, 18, 19] >>> L[:10:2] // 前10个数，每两个取一个 [0, 2, 4, 6, 8] >>> L[::5] // 所有数，每5个取一个 [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple： >>> (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2) 字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： >>> 'ABCDEFG'[:3] 'ABC' >>> 'ABCDEFG'[::2] 'ACEG' 迭代 如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。 在Python中，迭代是通过for ... in来完成的，而很多语言比如C语言，迭代list是通过下标完成的，比如Java代码： for (i=0; iPython的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。 list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代： >>> d = {'a': 1, 'b': 2, 'c': 3} >>> for key in d: ... print(key) ... a c b 因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。 默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。 由于字符串也是可迭代对象，因此，也可以作用于for循环： >>> for ch in 'ABC': ... print(ch) ... A B C 所以，当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。 那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断： >>> from collections import Iterable >>> isinstance('abc', Iterable) # str是否可迭代 True >>> isinstance([1,2,3], Iterable) # list是否可迭代 True >>> isinstance(123, Iterable) # 整数是否可迭代 False 最后一个小问题，如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身： >>> for i, value in enumerate(['A', 'B', 'C']): ... print(i, value) ... 0 A 1 B 2 C 上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码： >>> for x, y in [(1, 1), (2, 4), (3, 9)]: ... print(x, y) ... 1 1 2 4 3 9 列表生成时 列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。 举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))： >>> list(range(1, 11)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环： >>> L = [] >>> for x in range(1, 11): ... L.append(x * x) ... >>> L [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： >>> [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方： >>> [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100] 还可以使用两层循环，可以生成全排列： >>> [m + n for m in 'ABC' for n in 'XYZ'] ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现： >>> import os # 导入os模块，模块的概念后面讲到 >>> [d for d in os.listdir('.')] # os.listdir可以列出文件和目录 ['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode'] for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value： >>> d = {'x': 'A', 'y': 'B', 'z': 'C' } >>> for k, v in d.items(): ... print(k, '=', v) ... y = B x = A z = C 因此，列表生成式也可以使用两个变量来生成list： >>> d = {'x': 'A', 'y': 'B', 'z': 'C' } >>> [k + '=' + v for k, v in d.items()] ['y=B', 'x=A', 'z=C'] 最后把一个list中所有的字符串变成小写： >>> L = ['Hello', 'World', 'IBM', 'Apple'] >>> [s.lower() for s in L] ['hello', 'world', 'ibm', 'apple'] 生成器 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。 要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator： >>> L = [x * x for x in range(10)] >>> L [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] >>> g = (x * x for x in range(10)) >>> g at 0x1022ef630> 创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。 我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？ 如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值： >>> next(g) 0 >>> next(g) 1 >>> next(g) 4 >>> next(g) 9 >>> next(g) 16 >>> next(g) 25 >>> next(g) 36 >>> next(g) 49 >>> next(g) 64 >>> next(g) 81 >>> next(g) Traceback (most recent call last): File \"\", line 1, in StopIteration generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。 当然，上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象： >>> g = (x * x for x in range(10)) >>> for n in g: ... print(n) ... 0 1 4 9 16 25 36 49 64 81 所以，我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。 "},"python/basic/function.html":{"url":"python/basic/function.html","title":"函数","keywords":"","body":"函数 定义函数 在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。 我们以自定义一个求绝对值的my_abs函数为例： def my_abs(x): if x >= 0: return x else: return -x 空函数 如果想定义一个什么事也不做的空函数，可以用pass语句： def nop(): pass pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。 pass还可以用在其他语句里，比如： if age >= 18: pass // 缺少了pass，代码运行就会有语法错误 参数检查 调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError： >>> my_abs(1, 2) Traceback (most recent call last): File \"\", line 1, in TypeError: my_abs() takes 1 positional argument but 2 were given 但是如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别： >>> my_abs('A') Traceback (most recent call last): File \"\", line 1, in File \"\", line 2, in my_abs TypeError: unorderable types: str() >= int() >>> abs('A') Traceback (most recent call last): File \"\", line 1, in TypeError: bad operand type for abs(): 'str' 当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。 让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现： def my_abs(x): if not isinstance(x, (int, float)): raise TypeError('bad operand type') if x >= 0: return x else: return -x 添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误： >>> my_abs('A') Traceback (most recent call last): File \"\", line 1, in File \"\", line 3, in my_abs TypeError: bad operand type 返回多个值 函数可以返回多个值吗？答案是肯定的。 比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标： import math def move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny >>> x, y = move(100, 100, 60, math.pi / 6) >>> print(x, y) 151.96152422706632 70.0 但其实这只是一种假象，Python函数返回的仍然是单一值： >>> r = move(100, 100, 60, math.pi / 6) >>> print(r) (151.96152422706632, 70.0) 返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 调用函数 Python内置了很多有用的函数，我们可以直接调用。 要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。可以直接从Python的官方网站查看文档，也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。 调用abs函数： >>> abs(100) 100 >>> abs(-20) 20 >>> abs(12.34) 12.34 调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个： >>> abs(1, 2) Traceback (most recent call last): File \"\", line 1, in TypeError: abs() takes exactly one argument (2 given) 如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型： >>> abs('a') Traceback (most recent call last): File \"\", line 1, in TypeError: bad operand type for abs(): 'str' 而max函数max()可以接收任意多个参数，并返回最大的那个： >>> max(1, 2) 2 >>> max(2, 3, 1, -5) 3 数据类型转换 Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数： >>> int('123') 123 >>> int(12.34) 12 >>> float('12.34') 12.34 >>> str(1.23) '1.23' >>> str(100) '100' >>> bool(1) True >>> bool('') False 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”： >>> a = abs # 变量a指向abs函数 >>> a(-1) # 所以也可以通过a调用abs函数 1 函数参数 定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。 Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。 位置参数 一个计算x2的函数： def power(x): return x * x 对于power(x)函数，参数x就是一个位置参数。 当我们调用power函数时，必须传入有且仅有的一个参数x： >>> power(5) 25 >>> power(15) 225 现在，如果我们要计算x3怎么办？可以再定义一个power3函数，但是如果要计算x4、x5……怎么办？我们不可能定义无限多个函数。 你也许想到了，可以把power(x)修改为power(x, n)，用来计算xn，说干就干： def power(x, n): s = 1 while n > 0: n = n - 1 s = s * x return s 对于这个修改后的power(x, n)函数，可以计算任意n次方： >>> power(5, 2) 25 >>> power(5, 3) 125 修改后的power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。 默认参数 新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用： >>> power(5) Traceback (most recent call last): File \"\", line 1, in TypeError: power() missing 1 required positional argument: 'n' Python的错误信息很明确：调用函数power()缺少了一个位置参数n。 这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2： def power(x, n=2): s = 1 while n > 0: n = n - 1 s = s * x return s 这样，当我们调用power(5)时，相当于调用power(5, 2)： >>> power(5) 25 >>> power(5, 2) 25 而对于n > 2的其他情况，就必须明确地传入n，比如power(5, 3)。 从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意： 一是必选参数在前，默认参数在后，否则Python的解释器会报错; 二是当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。 可变参数 在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。 我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。 要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下： def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 但是调用的时候，需要先组装出一个list或tuple： >>> calc([1, 2, 3]) 14 >>> calc((1, 3, 5, 7)) 84 如果利用可变参数，调用函数的方式可以简化成这样： >>> calc(1, 2, 3) 14 >>> calc(1, 3, 5, 7) 84 所以，我们把函数的参数改为可变参数： def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数： >>> calc(1, 2) 5 >>> calc() 0 如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做： >>> nums = [1, 2, 3] >>> calc(*nums) // Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去 14 关键字参数 可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例： def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw) 函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数： >>> person('Michael', 30) name: Michael age: 30 other: {} >>> person('Bob', 35, city='Beijing') name: Bob age: 35 other: {'city': 'Beijing'} >>> person('Adam', 45, gender='M', job='Engineer') name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'} 关 关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。 "},"python/basic/file_parse.html":{"url":"python/basic/file_parse.html","title":"文件解析","keywords":"","body":"文件解析 TXT文件解析 打开文件 f = open(filename, access_mode='r', buffering=-1) # filename:文件名 # access_mode：打开方式（r读，w写，a追加） # buffering：默认值 文件操作 f = open('./test.txt', 'r') for line in f.readlines(): print(line) f.close() # read()读取整个文件到字符串变量中 # readline()读取文件中的一行，然后返回整行（包括行结束符）到字符串变量中 # readlines()读取整个文件，返回一个字符串列表，列表中的每个元素都是一个字符串，代表一行 # write()将字符串输出到文件中 f = open('./test.txt', 'w') f.write('welcome to my house') f.close() # writelines()将字符串列表写入文件，行结束符并不会自动被加入，需要手动在每行的结尾加入行结束符 f = open('./test.txt', 'w') w = ['hello\\n', 'world'] f.writelines(w) f.close() JSON文件解析 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯(包括C、C++、Java、JavaScript、Perl、Python等)。这些特性使JSON成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。 json的官方文档。 API API Annotation json.load( ) 把文件打开，并把字符串变换为数据类型 json.loads( ) 将 字符串 转换为 字典 json.dump( , ) 将数据写入json文件中 json.dumps( ) 将python中的 字典 转换为 字符串 文件转换 import json dict_data = {\"City\": \"Nanjing\", \"Year\": 2018, \"Province\": \"Jiangshu\"} # dumps：将python中的 字典 转换为 字符串 str_1 = json.dumps(dict_data) assert isinstance(str_1, str) # loads: 将 字符串 转换为 字典 dict_2 = json.loads(str_1) assert isinstance(dict_2, dict) 文件操作 import json dict_data = {\"City\": \"Nanjing\", \"Year\": 2018, \"Province\": \"Jiangshu\"} # dump: 将数据写入json文件中 with open(\"./test.json\", \"w\") as dump_f: json.dump(dict_data, dump_f, ensure_ascii=False, indent=4) # load:把文件打开，并把字符串变换为数据类型 with open(\"./test.json\", \"r\") as load_f: dict_3 = json.load(load_f) assert isinstance(dict_3, dict) Excel文件解析 四种方法使用范围比较 \\ xlrd xlwt XlsxWriter openpyxl 介绍 读取xls文件 写出xls文件 创建xlsx文件 读写xlsx、xlsm文件 读 √ × × √ 写 × √ √ √ xls √ √ × × xlsx × × √ √ 注：Excel2003即XLS文件有大小限制即65536行256列，所以不支持大文件，而Excel2007以上即XLSX文件的限制则为1048576行16384列。 xlwt写入xls文件 import xlwt book = xlwt.Workbook() # 新建工作簿 table = book.add_sheet('Over', cell_overwrite_ok=True) # 如果对同一单元格重复操作会发生overwrite Exception，cell_overwrite_ok为可覆盖 sheet = book.add_sheet('Test') # 添加工作页 sheet.write(1, 1, 'A') # 行，列，属性值,（1,1）为B2元素，从0开始计数 style = xlwt.XFStyle() # 新建样式 font = xlwt.Font() # 新建字体 font.name = 'Times New Roman' font.bold = True style.font = font # 将style的字体设置为font table.write(0, 0, 'Test', style) book.save(filename_or_stream='excel_test.xls') # 一定要保存 xlrd读取xls文件 import xlrd data = xlrd.open_workbook('./excel_test.xls') # 打开工作簿 print(data.sheet_names()) # 输出所有页的名称 table = data.sheets()[0] # 获取第一页 # table = data.sheet_by_index(0) # 通过索引获得第一页 # table = data.sheet_by_name('Over') # 通过名称来获取指定页 nrows = table.nrows # 为行数，整形 ncolumns = table.ncols # 为列数，整形 print(nrows) print(ncolumns) print(type(nrows)) print(table.row_values(0)) # 输出第一行值，为一个列表 # 遍历输出所有行值 for row in range(nrows): print(table.row_values(row)) # 输出某一个单元格值 print(table.cell(0, 0).value) print(table.row(0)[0].value) 综合使用python-excel三大模块完成Excel内容追加写入 import xlwt, xlrd from xlutils.copy import copy data = xlrd.open_workbook('excel_test.xls', formatting_info=True) excel = copy(wb=data) # 完成xlrd对象向xlwt对象转换 excel_table = excel.get_sheet(0) # 获得要操作的页 table = data.sheets()[0] nrows = table.nrows # 获得行数 ncols = table.ncols # 获得列数 values = [\"E\", \"X\", \"C\", \"E\", \"L\"] # 需要写入的值 for value in values: excel_table.write(nrows, 1, value) # 因为单元格从0开始算，所以row不需要加一 nrows = nrows + 1 excel.save('excel_test.xls') XlsxWriter import xlsxwriter workbook = xlsxwriter.Workbook('demo1.xlsx') # 创建一个Excel文件 worksheet = workbook.add_worksheet() # 创建一个工作表sheet对象 worksheet.set_column('A:A', 20) # 设定第一列（A）宽度为20像素 bold = workbook.add_format({'bold': True}) # 定义一个加粗的格式对象 # 向单元格写入数据 worksheet.write('A1', 'Hello') # 向A1单元格写入'Hello' worksheet.write('A2', 'World', bold) # 向A2单元格写入'World'并使用bold加粗格式 worksheet.write('B2', u'中文字符', bold) # 向B2单元格写入中文并使用加粗格式 worksheet.write(2, 0, 10) # 用行列表示法（行列索引都从0开始）向第2行、第0列（即A3单元格）和第3行、第0列（即A4单元格）写入数字 worksheet.write(3, 0, 20) worksheet.write(4, 0, '=SUM(A3:A4)') # 求A3、A4单元格的和并写入A5单元格，由此可见可以直接使用公式 # worksheet.insert_image('B5', './welcome.jpg') # 在B5单元格插入图片 workbook.close() # 关闭并保存文件 使用openpyxl写入xlsx文件 import openpyxl data = openpyxl.Workbook() # 新建工作簿 data.create_sheet('Sheet1') # 添加页 # table = data.get_sheet_by_name('Sheet1') # 获得指定名称页 table = data.active # 获得当前活跃的工作页，默认为第一个工作页 table.cell(1, 1, 'Test') # 行，列，值 这里是从1开始计数的 data.save('excel_test.xlsx') # 一定要保存 使用openpyxl读取xlsx文件 import openpyxl data = openpyxl.load_workbook('excel_test.xlsx') # 读取xlsx文件 table = data['Sheet'] # 获得指定名称的页 nrows = table.rows # 获得行数，类型为迭代器 ncols = table.columns # 获得列数，类型为迭代器 for row in nrows: print(row) # 包含了页名，cell，值 line = [col.value for col in row] # 取值 print(line) # 读取单元格 print(table.cell(1, 1).value) 综合使用openpyxl对Excel内容追加写入 import openpyxl data = openpyxl.load_workbook('excel_test.xlsx') # print(data.sheetnames) # 输出所有工作页的名称 # 取第一张表 sheetnames = data.sheetnames table = data[sheetnames[0]] # table = data.active # print(table.title) # 输出表名 nrows = table.max_row # 获得行数 ncolumns = table.max_column # 获得列数 print(nrows, ncolumns) values = ['E', 'X', 'C', 'E', 'L'] for value in values: table.cell(nrows + 1, 1).value = value nrows = nrows + 1 data.save('excel_test.xlsx') "},"python/basic/database.html":{"url":"python/basic/database.html","title":"数据库","keywords":"","body":"数据库 MySQL数据库 import pymysql class MysqlManager(object): def __init__(self, host='127.0.0.1', db='Test', user='root', password='123456', port=3306, charset='utf8mb4'): # 初始化数据库 self.__host = host self.__db = db self.__user = user self.__password = password self.__port = port self.__charset = charset self.__connect = None self.__cursor = None def _connect_db(self): # 连接数据库 params = { 'host': self.__host, 'db': self.__db, 'user': self.__user, 'password': self.__password, 'port': self.__port, 'charset': self.__charset } self.__connect = pymysql.connect(**params) self.__cursor = self.__connect.cursor() def _close_db(self): # 关闭数据库 self.__cursor.close() self.__connect.close() def _deal_values(self, value): if isinstance(value, str): # 如果是字符串则加上'' value = (\"'{value}'\".format(value=value)) elif isinstance(value, dict): # 如果是字典则变成key=value形式 result = [] for key, value in value.items(): value = self._deal_values(value) res = \"{key}={value}\".format(key=key, value=value) result.append(res) return result else: value = (str(value)) return value def insert(self, table, insert_data): # 插入数据：table为str类型、insert_data为包含dict的list；返回数据insert_num为int类型。 self._connect_db() try: insert_num = 0 for single_data in insert_data: key = ','.join(single_data.keys()) values = map(self._deal_values, single_data.values()) insert_data = ', '.join(values) sql = 'insert into {table}({key}) values ({val})'.format(table=table, key=key, val=insert_data) execute_num = self.__cursor.execute(sql) self.__connect.commit() insert_num += execute_num return insert_num except Exception as e: self.__connect.rollback() print(e) finally: self._close_db() def delete(self, table, condition): # 删除数据：table为str类型、condition为dict类型；返回数据delete_num为int类型。 self._connect_db() try: # 处理删除的条件 condition_list = self._deal_values(condition) condition_data = ' and '.join(condition_list) # 构建sql语句 sql = 'delete from {table} where {condition}'.format(table=table, condition=condition_data) delete_num = self.__cursor.execute(sql) self.__connect.commit() return delete_num except Exception as e: self.__connect.rollback() print(e) finally: self._close_db() def update(self, table, update_data, condition=None): # 修改数据：table为str类型、update_data为dict类型、condition为dict类型；返回数据update_num为int类型。 self._connect_db() try: # 处理传入的数据 update_list = self._deal_values(update_data) update_data_list = ','.join(update_list) # 判断是否有条件 if condition is not None: # 处理传入的条件 condition_list = self._deal_values(condition) condition_data = ' and '.join(condition_list) sql = 'update {table} set {values} where {condition}'.format(table=table, values=update_data_list, condition=condition_data) else: sql = 'update {table} set {values}'.format(table=table, values=update_data_list) update_num = self.__cursor.execute(sql) self.__connect.commit() return update_num except Exception as e: self.__connect.rollback() print(e) finally: self._close_db() def select(self, table, show_list, condition=None, get_one=False): # 查询数据：table为str类型、show_list为list类型、condition为dict类型、get_one为Boolean类型；返回数据result为tuple类型。 self._connect_db() try: # 处理显示的数据 show_list = ','.join(show_list) sql = 'select {key} from {table}'.format(key=show_list, table=table) # 处理传入的条件 if condition: condition_list = self._deal_values(condition) condition_data = 'and'.join(condition_list) sql = 'select {key} from {table} where {condition}'.format(key=show_list, table=table, condition=condition_data) self.__cursor.execute(sql) # 返回一条数据还是所有数据 if get_one: result_data = self.__cursor.fetchone() else: result_data = self.__cursor.fetchall() return result_data except Exception as e: print(e) finally: self._close_db() "},"python/data_analysis/numpy_1.html":{"url":"python/data_analysis/numpy_1.html","title":"Numpy介绍","keywords":"","body":"Numpy介绍 为什么会有Numpy Python中用列表(list)保存一组值，可以用来当作数组使用，不过由于列表的元素可以是任何对象，因此列表中所保存的是对象的指针。这样为了保存一个简单的[1,2,3]，需要有3个指针和三个整数对象。对于数值运算来说这种结构显然比较浪费内存和CPU计算时间。 此外Python还提供了一个array模块，array对象和列表不同，它直接保存数值，和C语言的一维数组比较类似。但是由于它不支持多维，也没有各种运算函数，因此也不适合做数值运算。 所以Numpy就这么登场了，NumPy是Python的一种开源的数值计算扩展。这种工具可用来存储和处理大型矩阵，比Python自身的嵌套列表（nested list structure)结构要高效的多（该结构也可以用来表示矩阵（matrix））。 NumPy的主要对象是同种元素的多维数组。这是一个所有的元素都是一种类型、通过一个正整数元组索引的元素表格(通常是元素是数字)。在NumPy中维度(dimensions)叫做轴(axes)，轴的个数叫做秩(rank)。 Numpy的所有的函数docs，点击查看。 Numpy的核心array对象以及创建array的方法 array对象的背景 Numpy的核心数据结构，就叫做array就是数组，array对象可以是一维数组，也可以是多维数组。 Python的List也可以实现相同的功能，但是array比List的优点在于性能好、包含数组元数据信息、大量的便捷函数。 Numpy成为事实上的Scipy、Pandas、Scikit-Learn、Tensorflow、PaddlePaddle等框架的“通用底层语言”。 Numpy的array和Python的List的一个区别，是它元素必须都是同一种数据类型，比如都是数字int类型，这也是Numpy高性能的一个原因。 创建array的方法 从Python的列表List和嵌套列表创建array。 # 创建一个一维数组，也就是Python的单元素List x = np.array([1, 2, 3, 4, 5, 6, 7, 8]) print(x) # 创建一个二维数组，也就是Python的嵌套List x = np.array( [ [1, 2, 3, 4], [5, 6, 7, 8] ] ) print(x) 使用预定函数arange、ones/ones_like、zeros/zeros_like、empty/empty_like、full/full_like、eye等函数创建。 # 使用arange创建数字序列 # arange([start,] stop[, step,], dtype=None) x = np.arange(10) print(x) y = np.arange(2, 10, 2) print(y) # 使用ones创建全是1的数组 # np.ones(shape, dtype=None, order='C') # shape : int or tuple of ints Shape of the new array, e.g., (2, 3) or 2. x = np.ones(10) print(x) y = np.ones((2, 3)) print(y) # 使用ones_like创建形状相同的数组 # ones_like(a, dtype=float, order='C') print(np.ones_like(x)) print(np.ones_like(X)) # 使用zeros创建全是0的数组 # np.zeros(shape, dtype=None, order='C') print(np.zeros(10)) print(np.zeros((3, 4))) # 使用zeros_like创建形状相同的数组 # np.zeros_like(a, dtype=None) print(np.zeros_like(x)) print(np.zeros_like(X)) # 使用empty创建全是0的数组 # empty(shape, dtype=float, order='C') # 注意：数据是未初始化的，里面的值可能是随机值不要用 print(np.empty(10)) print(np.empty((3, 4))) # 使用empty_like创建形状相同的数组 # empty_like(prototype, dtype=None) print(np.empty_like(x)) print(np.empty_like(X)) # 使用full创建指定值的数组 # np.full(shape, fill_value, dtype=None, order='C') print(np.full(10, 666)) print(np.full((3, 4), 888)) # 使用full_like创建形状相同的数组¶ # np.full_like(a, fill_value, dtype=None) print(np.full_like(x, 666)) print(np.full_like(X, 666)) 生成随机数的np.random模块构建。 # 使用random模块生成随机数的数组 # randn(d0, d1, ..., dn) print(np.random.randn()) print(np.random.randn(3)) print(np.random.randn(3, 4)) print(np.random.randn(3, 3, 4)) array本身的属性 shape：返回一个元组，表示array的维度。 # 创建一个一维数组，也就是Python的单元素List x = np.array([1, 2, 3, 4, 5, 6, 7, 8]) print(x) # 创建一个二维数组，也就是Python的嵌套List X = np.array( [ [1, 2, 3, 4], [5, 6, 7, 8] ] ) print(X) print(x.shape) print(X.shape) # (8,) # (2, 4) ndim：一个数字，表示array的维度的数目。 print(x.ndim) print(X.ndim) # 1 # 2 size：一个数字，表示array中所有数据元素的数目。 print(x.size) print(X.size) # 8 # 8 dtype：array中元素的数据类型。 print(x.dtype) print(X.dtype) # int64 # int64 array本身支持的大量操作和函数 直接逐元素的加减乘除等算数操作。 A = np.arange(10).reshape(2, 5) print(A) print(A + 3) print(A * 2) print(A ** 2) 更好用的面向多维的数组索引。 求sum/mean等聚合函数。 线性代数函数，比如求解逆矩阵、求解方程组。 Numpy对数组按索引查询 import numpy as np x = np.arange(20) X = np.arange(20).reshape(4, 5) print(x) print(X) 基础索引 # 一维数组 # 和Python的List一样 print(x[2], x[5], x[-1]) print(x[2:4]) print(x[2:-1]) print(x[-3:]) # 二维数组 # 分别用行坐标、列坐标，实现行列筛选 print(X[0, 0]) print(X[-1, 2]) print(X[:-1]) # 筛选多行 print(X[:2, 2:4]) # 筛选多行，然后筛选多列 print(X[:, 2]) # 筛选所有行，然后筛选多列 # 注意：切片的修改会修改原来的数组 # 原因：Numpy经常要处理大数组，避免每次都复制 x[2:4] = 666 print(x) 神奇索引 # 其实就是：用整数数组进行的索引，叫神奇索引 # 一维数组 x = np.arange(10) print(x) print(x[[3, 4, 7]]) indexs = np.array([[0, 2], [1, 3]]) print(x[indexs]) # 二维数组 X = np.arange(20).reshape(4, 5) print(X[[0, 2]]) # 筛选多行，列可以省略 print(X[[0, 2], :]) print(X[:, [0, 2, 3]]) # 筛选多列，行不能省略 print(X[[0, 2, 3], [1, 3, 4]]) # 同时指定行列-列表 布尔索引 # 一维数组 x = np.arange(10) print(x > 5) print(x[x > 5]) # 二维数组 X = np.arange(20).reshape(4, 5) print(X > 5) # X>5的boolean数组，既有行，又有列 print(X[X > 5]) print(X[X[:, 3] > 5]) Numpy常用random随机函数 官方文档地址。 rand(d0, d1, ..., dn)：返回数据在[0, 1)之间，具有均匀分布 print(np.random.rand(5)) print(np.random.rand(3, 4)) print(np.random.rand(2, 3, 4)) randn(d0, d1, ..., dn)：返回数据具有标准正态分布（均值0，方差1） print(np.random.randn(5)) print(np.random.randn(3, 4)) print(np.random.randn(2, 3, 4)) randint(low[, high, size, dtype])：生成随机整数，包含low，不包含high，如果high不指定，则从[0, low)中生成数字 print(np.random.randint(3)) print(np.random.randint(1, 10)) print(np.random.randint(10, 30, size=(5,))) print(np.random.randint(10, 30, size=(2, 3, 4))) random([size])：生成[0.0, 1.0)的随机数 print(np.random.random(5)) print(np.random.random(size=(3, 4))) print(np.random.random(size=(2, 3, 4))) choice(a[, size, replace, p])：a是一维数组，从它里面生成随机结果 print(np.random.choice(5, 3)) # 这时候，a是数字，则从range(5)中生成，size为3 print(np.random.choice(5, (2, 3))) print(np.random.choice([2, 3, 6, 7, 9], 3)) # 这时候，a是数组，从里面随机取出数字 print(np.random.choice([2, 3, 6, 7, 9], (2, 3))) shuffle(x)：把一个数组x进行随机排列 # 一维数组 a = np.arange(10) np.random.shuffle(a) print(a) # 如果是多维数组，则只会在第一维度上随机 A = np.arange(20).reshape(4, 5) np.random.shuffle(A) print(A) permutation(x)：把一个数组x进行随机排列，或者数字的全排列 print(np.random.permutation(10)) # 这时候，生成range(10)的随机排列 print(np.random.permutation(np.arange(9).reshape((3, 3)))) # 这时候，在第一维度进行打散 # 注意，这里不会更改原来的arr，会返回一个新的copy normal([loc, scale, size])：按照平均值loc和方差scale生成高斯分布的数字 print(np.random.normal(1, 10, 10)) print(np.random.normal(1, 10, (3, 4))) uniform([low, high, size])：在[low, high)之间生成均匀分布的数字 print(np.random.uniform(1, 10, 10)) print(np.random.uniform(1, 10, (3, 4))) Numpy的数学统计函数 Numpy有哪些数学统计函数 函数名 说明 np.sum 所有元素的和 np.prod 所有元素的乘积 np.cumsum 元素的累积加和 np.cumprod 元素的累积乘积 np.min 最小值 np.max 最大值 np.percentile 0-100百分位数 np.quantile 0-1分位数 np.median 中位数 np.average 加权平均，参数可以指定weights np.mean 平均值 np.std 标准差 np.var 方差 arr = np.arange(12).reshape(3, 4) print(np.sum(arr)) # 所有元素的和 print(np.prod(arr)) # 所有元素的乘积 print(np.cumsum(arr)) # 元素的累积加和 print(np.cumprod(arr)) # 元素的累积乘积 print(np.min(arr)) # 最小值 print(np.max(arr)) # 最大值 print(np.percentile(arr, [25, 50, 75])) # 0-100百分位数 print(np.quantile(arr, [0.25, 0.5, 0.75])) # 0-1分位数 print(np.median(arr)) # 中位数 weights = np.random.rand(*arr.shape) # 加权平均，参数可以指定weights np.average(arr, weights=weights) # weights的shape需要和arr一样 print(np.mean(arr)) # 平均值 print(np.std(arr)) # 标准差 print(np.var(arr)) # 方差 怎样实现按不同的axis计算 以上函数，都有一个参数叫做axis用于指定计算轴为行还是列，如果不指定，那么会计算所有元素的结果。 axis=0代表行、axis=1代表列，对于sum/mean/media等聚合函数： axis=0代表把行消解掉，axis=1代表把列消解掉。 arr = np.arange(20).reshape(4, 5) print(arr) print(arr.sum(axis=0)) print(arr.sum(axis=1)) Numpy计算数组中满足条件元素个数 arr = np.random.randint(1, 10000, size=int(1e8)) print(arr[:10]) # 计算下结果，用于对比是否准确 print(arr[arr > 5000].size) Numpy怎样给数组增加一个维度 背景 很多数据计算都是二维或三维的，对于一维的数据输入为了形状匹配，经常需升维变成二维。 需要 在不改变数据的情况下，添加数组维度；（注意观察这个例子，维度变了，但数据不变） 原始数组：一维数组arr=[1,2,3,4]，其shape是(4,)，取值分别为arr[0],arr[1],arr[2],arr[3]。 变形数组：二维数组arr[[1,2,3,4]]，其shape实(1,4), 取值分别为a[0,0],a[0,1],a[0,2],a[0,3]。 实操的3种方法 np.newaxis：关键字，使用索引的语法给数组添加维度。 # np.newaxis：关键字，使用索引的语法给数组添加维度 # 注意：np.newaxis其实就是None的别名 # print(np.newaxis is None) arr = np.arange(5) # 给一维向量添加一个行维度 print(arr[np.newaxis, :]) # 给一维向量添加一个列维度 print(arr[:, np.newaxis]) np.expand_dims(arr,axis)：方法，和np.newaxis实现一样的功能，给arr在axis位置添加维度。 arr = np.arange(5) # np.expand_dims方法实现的效果，和np.newaxis关键字是一模一样的 # 给一维数组添加一个行维度 print(np.expand_dims(arr, axis=0)) # 给一维数组添加一个列维度 print(np.expand_dims(arr, axis=1)) np.reshape(a, newshape)：方法，给一个维度设置为1完成升维。 arr = np.arange(5) # 给一维数组添加一个行维度 print(np.reshape(arr, (1, 5))) print(np.reshape(arr, (1, -1))) # -1表示让Numpy自己计算有几列 # 给一维数组添加一个列维度 print(np.reshape(arr, (-1, 1))) # -1表示让Numpy自己计算有几行 Numpy重要的数组合并操作 背景：在给机器学习准备数据的过程中，经常需要进行不同来源的数据合并的操作。 两类场景： 给已有的数据添加多行，比如增添一些样本数据进去； 给已有的数据添加多列，比如增添一些特征进去； 以下操作均可以实现数组合并： np.concatenate(array_list, axis=0/1）：沿着指定axis进行数组的合并。 np.vstack或者np.row_stack(array_list)：垂直vertically、按行row wise进行数据合并。 np.hstack或者np.column_stack(array_list)：水平horizontally、按列column wise进行数据合并。 # 给数据添加新的多行 a = np.arange(6).reshape(2, 3) b = np.random.randint(10, 20, size=(4, 3)) print(np.concatenate([a, b])) print(np.vstack([a, b])) print(np.row_stack([a, b])) # 给数据添加新的多列 A = np.arange(12).reshape(3, 4) B = np.random.randint(10, 20, size=(3, 2)) print(np.concatenate([A, B], axis=1)) print(np.hstack([A, B])) print(np.column_stack([A, B])) Numpy怎么对数组进行排序 Numpy给数组排序有三种方法： numpy.sort：返回排序后数组的拷贝。 array.sort：原地排序数组而不是返回拷贝。 numpy.argsort：间接排序，返回的是排序后的数字索引。 三种方法都支持一个参数kind，可以是以下一个值： quicksort：默认值，快速排序，平均O(nlogn)，不稳定情况。 mergesort：归并排序，平均O(nlogn)，稳定排序。 heapsort：堆排序，平均O(nlogn)，不稳定排序。 stable：稳定排序。 arr = np.array([1, 2, 5, 3, 8, 6, 9, 3]) print(np.sort(arr)) # 返回排序后的拷贝数组 arr.sort() # 原地排序 print(arr) indices = np.argsort(arr) # 获得排序元素对应的索引数字列表 print(arr[indices]) # 直接获取对应的数据列表 Numpy怎么实现数组的乘法 按照两个相乘数组的维度的不同，分为以下几种乘法： 数字与一维/二维数组相乘。 一维数组与一维数组相乘。 一维数组与二维数组相乘。 二维数据与二维数组相乘。 乘法函数 *符号或者np.multily：逐元素乘法，对应位置的元素相乘，要求shape相同。 @符号或者np.matmul：矩阵乘法，形状要求满足(n, k),(k, m)—>（n, m）。 np.dot：点积乘法（也叫内积或数量积），两个向量a=[a1, a2,···，an]和b=[b1, b2, ···, bn]的点积定义为：a·b = a1b1 + a2b2 + ··· + anbn。 # 数字与一维/二维数组相乘 A = np.arange(10) # 一维数组 print(A * 0.5) B = np.arange(12).reshape(3, 4) print(B * 0.5) # 一维数组与一维数组相乘 A = np.arange(1, 11) B = np.arange(11, 21) print(np.multiply(A, B)) # 逐元素乘法 print(A * B) print(np.matmul(A, B)) print(A @ B) print(np.dot(A, B)) # 一维数组与二维数组相乘 A = np.arange(1, 5) B = np.arange(1, 21).reshape(5, 4) print(A@B) "},"python/data_analysis/numpy_2.html":{"url":"python/data_analysis/numpy_2.html","title":"Array对象","keywords":"","body":""},"python/django/django.html":{"url":"python/django/django.html","title":"创建第一个 Django 应用","keywords":"","body":"创建第一个 Django 应用 创建项目 创建项目目录并安装虚拟环境： yvesdeMacBook-Air:Python yves$ mkdir Propaganda // 创建项目目录 yvesdeMacBook-Air:Python yves$ cd Propaganda yvesdeMacBook-Air:Python yves$ pipenv install // 安装虚拟环境 Warning: the environment variable LANG is not set! We recommend setting this in ~/.profile (or equivalent) for proper expected behavior. Creating a virtualenv for this project… Pipfile: /Users/yves/Documents/GitHub/Python/Propaganda/Pipfile Using /usr/local/bin/python3 (3.6.4) to create virtualenv… ⠧ Creating virtual environment...Already using interpreter /usr/local/bin/python3 Using base prefix '/Library/Frameworks/Python.framework/Versions/3.6' New python executable in /Users/yves/.local/share/virtualenvs/Propaganda-ojQAzsrM/bin/python3 Also creating executable in /Users/yves/.local/share/virtualenvs/Propaganda-ojQAzsrM/bin/python Installing setuptools, pip, wheel... done. ✔ Successfully created virtual environment! Virtualenv location: /Users/yves/.local/share/virtualenvs/Propaganda-ojQAzsrM Creating a Pipfile for this project… Pipfile.lock not found, creating… Locking [dev-packages] dependencies… Locking [packages] dependencies… Updated Pipfile.lock (ca72e7)! Installing dependencies from Pipfile.lock (ca72e7)… &#x1F40D; ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ 0/0 — 00:00:00 To activate this project's virtualenv, run pipenv shell. Alternatively, run a command inside the virtualenv with pipenv run. 启动开发环境并安装Django： yvesdeMacBook-Air:Propaganda yves$ pipenv shell // 启动虚拟环境 Launching subshell in virtual environment… bash-3.2$ . /Users/yves/.local/share/virtualenvs/Propaganda-ojQAzsrM/bin/activate (Propaganda) bash-3.2$ pipenv install Django // 安装Django Installing Django… Adding Django to Pipfile's [packages]… ✔ Installation Succeeded Pipfile.lock (12ffd6) out of date, updating to (ca72e7)… Locking [dev-packages] dependencies… Locking [packages] dependencies… ✔ Success! Updated Pipfile.lock (12ffd6)! Installing dependencies from Pipfile.lock (12ffd6)… &#x1F40D; ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ 4/4 — 00:00:04 Django常见命令有创建项目、创建应用、创建超级用户、数据表创建及更新、启动服务器等，这些命令都包含在 django-admin.py 和 manage.py 里。除此以外 manage.py 还包含其它有用的命令，基本包含： 创建新项目：django-admin startproject project_name 创建新应用：python manage.py startapp app_name 检测模型变化生成新的数据库迁移文件：python manage.py makemigrations [app_name] 同步数据库与模型：python manage.py migrate 启动服务器：python manage.py runserver 创建超级用户：python manage.py createsuperuser 修改用户密码：python manage.py changepassword username 打开交互终端：python manage.py shell（dbshell指数据库交互） 查看当前版本：python manage.py version 清空数据库内容只留下空表：python manage.py flush 搜集静态文件：python manage.py collectstatic 创建Django项目并启动验证是否成功： (Propaganda) bash-3.2$ django-admin startproject Propaganda // 创建项目 (Propaganda) bash-3.2$ ll // 项目文件结构 drwxr-xr-x 7 yves staff 224 Dec 6 21:06 ./ drwxr-xr-x 12 yves staff 384 Dec 6 20:34 ../ -rw-r--r-- 1 yves staff 168 Dec 6 20:37 Pipfile -rw-r--r-- 1 yves staff 1639 Dec 6 20:37 Pipfile.lock drwxr-xr-x 7 yves staff 224 Dec 6 20:56 Propaganda/ -rwxr-xr-x 1 yves staff 630 Dec 6 20:56 manage.py* (Propaganda) bash-3.2$ python manage.py runserver // 启动项目 Watching for file changes with StatReloader Performing system checks... System check identified no issues (0 silenced). You have 17 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions. Run 'python manage.py migrate' to apply them. December 06, 2019 - 13:14:35 Django version 3.0, using settings 'Propaganda.settings' Starting development server at http://127.0.0.1:8000/ Quit the server with CONTROL-C. 在浏览器输入 http://127.0.0.1:8000/ 看到Django启动页即表示项目创建成功。 创建应用与细节优化 应用创建 项目创建成功并验证通过后就可以创建相关应用： (Propaganda) bash-3.2$ python manage.py startapp chatriq 创建成功后需要在 settings.py 文件中加入相应配置： INSTALLED_APPS = [ 'chatriq' ] 项目细节优化 在项目根目录下创建 apps 包目录，用于统一管理后期创建的应用，这需要在 settings.py 文件里新增一条配置： sys.path.insert(0, os.path.join(BASE_DIR, 'apps')) # 将apps目录加到python的搜索目录中去 修改 settings.py 文件里的配置： LANGUAGE_CODE = 'zh-hans' TIME_ZONE = 'Asia/Shanghai' USE_TZ = False 在根目录下创建 static 目录用于存放静态文件，创建 templates 文件夹用于存放模板文件，并在 settings.py 文件中添加配置： STATIC_URL = '/static/' STATICFILES_DIRS = ( os.path.join(BASE_DIR, 'static'), ) 最终，目录结构如下： (Propaganda) bash-3.2$ ll -rw-r--r-- 1 yves staff 168 Dec 6 20:37 Pipfile -rw-r--r-- 1 yves staff 1639 Dec 6 20:37 Pipfile.lock drwxr-xr-x 8 yves staff 256 Dec 6 21:43 Propaganda/ drwxr-xr-x 4 yves staff 128 Dec 6 21:41 apps/ -rw-r--r-- 1 yves staff 0 Dec 6 21:14 db.sqlite3 -rwxr-xr-x@ 1 yves staff 630 Dec 6 20:56 manage.py drwxr-xr-x 2 yves staff 64 Dec 6 21:26 static/ drwxr-xr-x 2 yves staff 64 Dec 6 21:26 templates/ 数据库配置 在 settings.py 文件中可以配置项目连接的数据库信息，由于本项目暂时不涉及数据库相关操作。 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), } } 生成表迁移数据并在数据库中创建对应表文件： (Propaganda) bash-3.2$ python manage.py makemigrations No changes detected (Propaganda) bash-3.2$ python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, sessions Running migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying admin.0003_logentry_add_action_flag_choices... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying auth.0009_alter_user_last_name_max_length... OK Applying auth.0010_alter_group_name_max_length... OK Applying auth.0011_update_proxy_permissions... OK Applying sessions.0001_initial... OK 至此，Django项目应用创建完毕，后续更新编码过程中的细节与注意事项。 "},"python/django/django_deploy.html":{"url":"python/django/django_deploy.html","title":"Django 应用部署与监控","keywords":"","body":"Django 应用部署与监控 1、部署准备 一台云服务器，初级版（1核1G）即可，安装CentOS7.2版本操作系统，建议最好使用阿里云；一个已经完成ICP备案的域名。 2、环境搭建 2.1、新增用户 操作CentOS服务器，最好不要使用root根用户，其一是防止误操作；其二是避免在部署的过程中出现权限相关问题。 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ adduser yves # 添加yves用户 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ passwd yves # 设置yves的操作密码 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ usermod -aG wheel yves # 将yves添加到超级权限组 2.2、Python环境 安装Python环境之前，需要在操作系统上安装必要软件并更新yum源。 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ sudo yum update # 更新yum源 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ sudo yum upgrade [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ sudo yum install -y openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel gcc # 安装必要软件 这个步骤需要一定时间，耐心等待完成之后再进行下一步的安装Python-3.6.4。 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ mkdir src # 家目录下新建src目录存放下载文件 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ cd src # 进入src目录 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ wget https://www.python.org/ftp/python/3.6.4/Python-3.6.4.tgz # 下载Python-3.6.4 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ tar -zxvf Python-3.6.4.tgz # 解压 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ cd Python-3.6.4 # 进入解压目录 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ ./configure LD_RUN_PATH=/usr/local/lib LDFLAGS=\"-L/usr/local/lib\" CPPFLAGS=\"-I/usr/local/include\" [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ make LD_RUN_PATH=/usr/local/lib # 编译 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ sudo make install # 安装 上述下载、编译、安装等操作完成后，需要验证是否安装成功，出现下列版本信息即表示安装成功。 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ python3 -V Python 3.6.4 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ pip3 -V pip 19.3.1 from /usr/local/lib/python3.6/site-packages/pip (python 3.6) 安装最好用的python虚拟环境和包管理工具pipenv。 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ sudo pip3 install pipenv 问题：sudo: pip3: command not found 在环境变量中添加 alias sudo='sudo env PATH=$PATH' 并使其生效即可。 2.3、MySQL数据库安装 CentOS默认安装mariadb数据库，首先你需要卸载. [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ yum remove mariadb-libs.x86_64 安装MySQL数据库。 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ cd ~/src/ # 进入src目录 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm # 下载安装依赖文件 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ sudo yum localinstall mysql57-community-release-el7-11.noarch.rpm [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ sudo yum install mysql-community-server # 安装MyS数据库 MySQL数据库的相关操作。 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ service mysqld start # 启动 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ service mysqld stop # 停止 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ service mysqld restart # 重启 查看MySQL数据库的初始密码。 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ cat /var/log/mysqld.log | grep password 登录MySQL数据库。 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ mysql -uroot -p 修改MySQL数据库密码。 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ SET PASSWORD = PASSWORD('123456'); 开启远程连接 mysql> show databases; mysql> use mysql; mysql> show tables; mysql> select Host, User from user \\G; mysql> update user set host = '%' where user = 'root'; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql> flush privileges; Query OK, 0 rows affected (0.00 sec) 开启genelog mysql> set global general_log_file=\"/tmp/general.log\"; mysql> set global general_log=on; 创建用户 mysql> create user 'imooc'@'%' identified by '123456'; 赋于用户权限 mysql> grant all privileges on *.* to 'imooc'@'%' identified by '123456' with mysql> grant option; # 所有权限 mysql> grant select on *.* to 'imooc'@'%' identified by '123456' with grant option; # 查询权限 mysql> revoke all privileges on *.* from imooc; # 收回权限 mysql> flush privileges; 忘记密码 [yves@iz2ze0mhixialmdhi9pn5vz ~]$ sudo vim /etc/my.cnf # 添加skip-grant-tables mysql> show databases; mysql> user mysql; mysql> update user set authentication_string = password(\"123456\") where user = 'root'; [yves@iz2ze0mhixialmdhi9pn5vz ~]$ sudo vim /etc/my.cnf # 去除skip-grant-tables [yves@iz2ze0mhixialmdhi9pn5vz ~]$ sudo service mysqld restart 3、部署代码 将项目代码上传到部署目录下，方法比较多，推荐使用Git进行代码版本的管理，首先需要在服务器上安装相关应用并从远程仓库拉取代码，拉取完成后修改成生产环境的配置。 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ sudo yum install git # 安装git应用 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ mkdir ~/apps/ # 创建项目部署目录 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ cd ~/apps/ [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ git clone '远程仓库地址' # 拉取代码 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ cd '项目目录' [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ pipenv install --deploy --ignore-pipfile # 安装所需依赖 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ pipenv run python manage.py migrate # 创建数据库 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ pipenv run python manage.py runserver 0.0.0.0:8000 # 启动服务 服务启动后，即可以通过公网IP:8000端口访问应用，注意：务必在阿里云管理控制台放开8000端口，否则无法访问。 4、Gunicorn安装与使用 直接使用runserver命令启动的开发服务器并不适用与生产环境，因此使用Gunicorn作为生产环境服务器。 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ pipenv install gunicorn # 安装gunicorn [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ pipenv run gunicorn projectname.wsgi -w 2 -k gthread -b 0.0.0.0:8000 # 项目目录下启动 启动服务后，即可以通过公网IP:8000端口访问应用，但此时css样式全部未加载导致页面乱的一塌糊涂，这并非bug，而是由于处理静态文件请求并不是Gunicorn擅长的事情，应该交由更专业的Nginx去做。 5、Nginx服务器安装与使用 Nginx是一个高性能的HTTP和反向代理web服务器，它的功能非常多，这里主要用它来处理静态文件以及将非静态文件的请求反向代理给Gunicorn。 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ sudo yum install epel-release -y [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ sudo yum install nginx -y # 安装Nginx [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ sudo systemctl start nginx # 启动nginx [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ sudo systemctl stop nginx # 停止nginx [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ sudo systemctl restart nginx # 重启nginx [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ 直接在浏览器输入公网IP，看到nginx欢迎页面即表示安装并启动成功。下面就是修改应用中的settings.py配置文件，推荐Djecrety生成一个一个线上环境的SECRET_KEY。 DEBUG = False ALLOWED_HOSTS = ['127.0.0.1', 'localhost ', '公网IP或域名'] SECRET_KEY = ’***‘ STATICFILES_DIRS # 注释 STATIC_ROOT = os.path.join(BASE_DIR, 'static') # 新增 将项目的静态资源统一收集到static目录下。 pipenv run python manage.py collectstatic Nginx的配置位于/etc/nginx/nginx.conf文件中，其中项目的配置文件可以在/etc/nginx/conf.d/目录下新增，但是必须以.conf后缀结尾。 server { charset utf-8; listen 80; server_name 公网IP或域名; location /static { alias 绝对路径; } location /media { alias 绝对路径; } location / { proxy_set_header Host $host; proxy_pass http://127.0.0.1:8000; } } 配置文件新增完成之后，重启Nginx即可访问应用，至此基本完成Nginx与Gunicorn部署Django应用的目标。 6、Supervisor安装与使用 由于服务器与网络存在不稳定的情况，因此直接在控制台启动应用的方式存在宕机的风险，并且没办法对相关进程进行监控，因此使用Supervisor来管理Gunicorn进程，这样当服务器重新启动或者Gunicorn进程意外崩溃后，Supervisor会帮我们自动重启Gunicorn。 由于Supervisor目前还不支持Python3，因此需要使用CentOS系统自带的python2版本进行安装。 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ pip install supervisor 在家目录下新建相关的文件夹。 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ mkdir -p ~/etc/supervisor/conf.d # 创建配置文件夹 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ mkdir -p ~/etc/supervisor/var/log # 创建日志文件夹 [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ cd ~/etc/ [yves@iZ2zefeybcvjrhsdgz4uymZ ~]$ echo_supervisord_conf > supervisord.conf # 生成supervisor配置文件 修改supervisor.conf，让Supervisor进程产生的一些文件生成到上面我们创建的目录下，而不是其默认指定的地方。 [unix_http_server] file=/home/yves/etc/supervisor/var/supervisor.sock logfile=/home/yves/etc/supervisor/var/log/supervisord.log pidfile=/home/yves/etc/supervisor/var/supervisord.pid user=yves [supervisorctl] serverurl=unix:///home/yves/etc/supervisor/var/supervisor.sock files=/home/yves/etc/supervisor/conf.d/*.ini 配置修改完成之后需要在conf.d文件夹下新增应用的配置文件，注意文件必须以.ini结尾。 [program:projectname] command=pipenv run gunicorn projectname.wsgi -w 2 -k gthread -b 127.0.0.1:8000 directory=/home/yves/apps/projectname autostart=true autorestart=unexpected user=yves stdout_logfile=/home/yves/etc/supervisor/var/log/projectname-stdout.log stderr_logfile=/home/yves/etc/supervisor/var/log/projectname-stderr.log 启动supervisor。 supervisord -c ~/etc/supervisord.conf # -c 表示根据配置文件启动 进入supervisor管理控制台。 supervisorctl -c ~/etc/supervisord.conf 7、问题与解决 7.1、后台管理系统图片上传报500错误 这是由于Nginx的权限问题导致的，网上大多数资料说将'Chmod 777 /media'执行就好，但是我试了不行，后来将/etc/nginx/nginx.conf中的user改成root就好了。 "},"pleasure/google_hacking.html":{"url":"pleasure/google_hacking.html","title":"通过 Google Hacking 语法进行信息采集","keywords":"","body":"通过 Google Hacking 语法进行信息采集 语法简介 site: 搜索范围限制在某网站或顶级域名中，这个也很有用，例如: site:www.4ngel.net 将返回所有和 4ngel.net 这个站有关的URL。 filetype: 搜索特定类型文档，例如: filetype:doc 将返回所有以 doc 结尾的文件 URL，当然如果你找.bak、.mdb或.inc也是可以的，获得的信息也许会更丰富。 inurl: 搜索指定的字符是否存在于URL中，例如: inurl:admin 将返回N个类似于这样的连接:http://www.xxx.com/xxx/admin 用来找管理员登陆的URL，allinurl 也同 inurl 类似，可指定多个字符。 intext: 正文中搜索某个字符做为搜索条件，如在google里输入 intext:动网 将返回所有在网页正文部分包含”动网”的网页，allintext:使用方法和intext类似。 intitle: 标题中搜索是否有我们所要找的字符,例如搜索 intitle:安全天使 将返回所有网页标题中包含”安全天使”的网页,同理allintitle:也同intitle类似. cache: 搜索谷歌缓存页面（类似百度快照）搜索google里关于某些内容的缓存,有时候也许能找到一些好东西。 define: 查询单词或者术语的定义，搜索某个词语的定义，搜索 define:hacker 将返回关于hacker的定义。 info: 查找指定站点的一些基本信息。 link: 搜索所有链接到某个URL地址的网页，例如搜索 link:www.4ngel.net 可以返回所有和 www.4ngel.net 做了链接的URL。 inanchor: 锚链链接搜索在做网站中有时候用锚点来链接一个页面中的其它部分内容，这样方便浏览和定位。也就是说锚点链接的内容通常是网页内容中重要的章节或内容的开始部分，因而对它们的搜索也更能反映网页的主题内容，提高搜索结果的准确度。对于熟悉网页制作的人来说，可以从网页源代码中查看有锚点的HTML代码。 related: 相关网址查找与某个页面结构内容相似的页面，“related”用来搜索结构内容方面相似的网页。related语法对于发现某一类信息非常有用，比如当你用related搜索一个图书馆网址的时候会出来大量图书馆的网站，如【related:lib.nit.net.cn】；当搜索某期刊网址的时候，能搜索出大量给学科领域的相关期刊，如【related:www.lis.ac.cn】。 初阶搜索 1、默认模糊搜索、自动拆分短语 搜索引擎基本一样的语法，直接在搜索框中输入搜索词时，谷歌默认进行模糊搜索，并能对长短语或语句进行自动拆分成小的词进行搜索。 2、短语精确搜索。 — “” 给关键词加上半角引号实现精确搜索，不进行分词。 3、通配符。 — “※” 谷歌的通配符是星号“*”，必须在精确搜索符双引号内部使用。用通配符代替关键词或短语中无法确定的字词。 4、点号匹配任意字符。 — . 与通配符星号“*”不一样的是，点号“.”匹配的是字符，不是字、短语等内容。保留的字符有[、(、-等。 5、布尔逻辑：与或非：and，|,or,-” 布尔逻辑是许多检索系统的基本检索技术，在搜索引擎中也一样适用，在谷歌网页搜索中需要注意的是：谷歌和许多搜索引擎一样，多个词间的逻辑关系默认的是逻辑与（空格）。当用逻辑算符的时候，词与逻辑算符之间用需要空格分隔，包括后面讲的各种语法，均要有空格。逻辑非是特例，即减号必须与对应的词连在一起。对于复杂的逻辑关系，可用括号分组。 6、基本搜索符号约束 加号“+”用于强制搜索，即必须包含加号后的内容。一般与精确搜索符一起应用。关键词前加“-”减号,要求搜索结果中包含关键词,但不包含减号后的关键词，用关于搜索结果的筛选。 7、数字范围: .. 用两个点号“..”表示一个数字范围。一般应用于日期、货币、尺寸、重量、高度等范围的搜索。用作范围时最好给一定的含义。 8、括号分组: () 逻辑组配时分组，避免逻辑混乱。括号“()”是分组符号。 高阶用法 1、查找可以未经授权就可以访问的phpMyAdmin的后台页面 inurl:.php? intext:CHARACTER_SETS,COLLATIONS, ?intitle:phpmyadmin 2、搜索可能存在openssl心脏出血漏洞的站点 \"OPENSSL\" AND \"1.0.1 SERVER AT\" OR \"1.0.1A SERVER AT\" OR \"1.0.1B SERVER AT\" OR \"1.0.1C SERVER AT\" OR \"1.0.1D SERVER AT\" OR \"1.0.1E SERVER AT\" OR \"1.0.1F SERVER AT\" 查找注射点 site:xx.com filetype:asp site:tw inurl:asp?id= 这个是找台湾的 site:jp inurl:asp?id= 这个是找日本的 site:ko inurl:asp?id= 这个是找韩国的 intitle:旁注- 网站xxxfiletype:asp inurl:editor/db/ inurl:eWebEditor/db/ inurl:bbs/data/ inurl:databackup/ inurl:blog/data/ inurl:okedata inurl:bbs/database/ inurl:conn.asp inurl:inc/conn.asp 上传漏洞 /eWebEditor/upload.asp #eWebEditor上传页面 /editor/upload.asp #eWebEditor上传页面 /bbs/upfile.asp #动网论坛上传页面 /forum/upfile.asp #动网论坛上传页面 /dvbbs/upfile.asp #动网论坛上传页面 /upfile_soft.asp #动力管理系统上传页面 /upload.asp?action=upfile #乔客6.0上传页面 /upfile.asp #动网论坛上传页面 /bbs/down_addsoft.asp #动网论坛插件上传页面 /bbs/down_picupfile.asp #动网论坛插件上传页面 /down_picupload.asp #动网论坛插件上传页面 /admin/admin_upfile.asp #管理员后台上传页面 /admin/upfile.asp #管理员后台上传页面 /admin/upload.asp #管理员后台上传页面 /admin/uploadfaceok.asp #尘缘上传页面 /news/admin/upfile.asp #新闻管理上传页面 /admin_upfile.asp #飞龙文章管理系统 v2.0 /user_upfile.asp #飞龙文章管理系统 v2.0 /upload_flash.asp #秋叶购物商城上传页面 /Saveannounce_upload.asp #购物中心上传页面 /UploadFace.asp #沸腾展望新闻系统 v1.1 /bbs/diy.asp #Domian3.0默认木马 /UploadSoft/diy.asp #Domian3.0默认木马 /diy.asp #Domian3.0默认木马 /upload/upload.asp #某某文章管理系统 /mybbs/saveup.asp #MYBBS论坛上传页面 /dxxobbs/upload.asp #DxxoBBS论坛上传页面 /img_upfile.asp #任我飞扬驿站上传页面 /Upfile_SoftPic.asp #动力管理系统上传页面 /upfile_flash.asp #秋叶购物商城上传页面 数据库 database/PowerEasy4.mdb #动易网站管理系统4.03数据库 database/PowerEasy5.mdb database/PowerEasy6.mdb database/PowerEasy2005.mdb database/PowerEasy2006.mdb database/PE_Region.mdb data/dvbbs7.mdb #动网论坛数据库 databackup/dvbbs7.mdb #动网论坛备份数据库 bbs/databackup/dvbbs7.mdb #动网论坛备份数据库 data/zm_marry.asp #动网sp2美化版数据库 databackup/dvbbs7.mdb admin/data/qcdn_news.mdb #青创文章管理系统数据库 firend.mdb #交友中心数据库 database/newcloud6.mdb #新云管理系统6.0数据库 database/%23newasp.mdb #新云网站系统 blogdata/L-BLOG.mdb #L-BLOG v1.08数据库 blog/blogdata/L-BLOG.mdb #L-BLOG v1.08数据库 database/bbsxp.mdb #BBSXP论坛数据库 bbs/database/bbsxp.mdb #BBSXP论坛数据库 access/sf2.mdb #雪人论坛程序v2.0数据库 data/Leadbbs.mdb #LeadBBS论坛 v3.14数据库 bbs/Data/LeadBBS.mdb #LeadBBS论坛 v3.14数据库 bbs/access/sf2.mdb #雪人论坛程序v2.0数据库 fdnews.asp #六合专用BBS数据库 bbs/fdnews.asp #六合专用BBS数据库 admin/ydxzdate.asa #雨点下载系统 v2.0+sp1数据库 data/down.mdb #动感下载系统xp ver2.0数据库 data/db1.mdb #动感下载系统xp v1.3数据库 database/Database.mdb #轩溪下载系统 v3.1数据库 db/xzjddown.mdb #lhdownxp下载系统数据库 db/play.asp #娱乐先锋论坛 v3.0数据库 mdb.asp #惊云下载系统 v1.2数据库 admin/data/user.asp #惊云下载系统 v3.0数据库 data_jk/joekoe_data.asp #乔客6.0数据库 data/news3000.asp #沸腾展望新闻系统 v1.1数据库 data/appoen.mdb #惠信新闻系统4.0数据库 data/12912.asp #飞龙文章管理系统 v2.1数据库 database.asp #动感极品下载管理系统 v3.5 download.mdb #华仔软件下载管理系统 v2.3 dxxobbs/mdb/dxxobbs.mdb #dxxobbs论坛数据库 db/6k.asp #6kbbs 用户名:admin 密码:6kadmin database/snowboy.mdb #雪孩论坛 默认后台admin/admin_index.asp database/%23mmdata.mdb #依爽社区 editor/db/ewebeditor.mdbeWebEditor/db/ewebeditor.mdb 管理入口 admin admin_index admin_admin index_admin admin/index admin/default admin/manage admin/login manage_index index_manage superadmin 说明.txt manager/login manager/login.asp manager/admin.asp login/admin/admin.asp houtai/admin.asp guanli/admin.asp denglu/admin.asp admin_login/admin.asp admin_login/login.asp admin/manage/admin.asp admin/manage/login.asp admin/default/admin.asp admin/default/login.asp member/admin.asp member/login.asp administrator/admin.asp administrator/login.asp phpmyadmin include/config.inc.php include/config.php lib/config.php "},"pleasure/google_email.html":{"url":"pleasure/google_email.html","title":"怎么申请谷歌邮箱","keywords":"","body":"怎么申请谷歌邮箱 为什么要申请 谷歌邮箱是世界上最好用的邮箱，没有之一。由于在全球市场上的霸主地位，因而许多网站都可以使用谷歌邮箱进行第三方登录。 怎么申请 网页上按照正常操作申请谷歌邮箱大概率不能成功（被黑产玩坏了），因而需要借助移动端进行申请注册，具体步骤请参考视频。 "},"pleasure/vps.html":{"url":"pleasure/vps.html","title":"如何开心愉快","keywords":"","body":"如何开心愉快 免费资源 OR 收费资源 网上有很多免费的科学上网工具，但一般带宽设限使用时相当慢，其次则是客户端广告较多影响体验。因此比较推荐购买 VPS 主机资源进行服务器搭建。 国内市占率较高的主要有两家，分别是 搬瓦工 与 Vultr ，两者之间的主要区别在于：前者是按年或月收费，后者则按照使用时长收费。 购买链接： 搬瓦工购买链接 Vultr购买链接 服务器远程连接工具 请下载《电脑装机软件合集》里的 SecureCRT远程连接软件，安装后使用。 安装搭建脚本 使用Secure CRT工具连接成功后，粘贴下面的命令进行操作： [root@vultr ~]# yum install -y wget && wget --no-check-certificate -O shadowsocks-libev.sh https://raw.githubusercontent.com/uxh/shadowsocks_bash/master/shadowsocks-libev.sh && bash shadowsocks-libev.sh 回车后系统会自行下载脚本文件并运行，按照下图提示，我们输入1选择安装服务，回车继续： 2020-01-12 15:44:00 (51.7 MB/s) - ‘shadowsocks-libev.sh’ saved [21414/21414] ============================================== Shadowsocks Server Management Script (libev) ============================================== 1. Shadowsocks Server Install 2. Shadowsocks Server Uninstall 3. Shadowsocks Server Update ---------------------------------------------- 4. Shadowsocks Server Start 5. Shadowsocks Server Stop 6. Shadowsocks Server Restart ---------------------------------------------- 7. Shadowsocks Config Status 8. Shadowsocks Config Modify ============================================== Not installed Please Enter the Number:1 回车后系统会进入安装界面，我们首先依次输入 SS 的各项信息，然后回车继续即可： [Info] Start set shadowsocks's config information... [Info] Wherever you are not sure, just press Enter to continue. Please enter shadowsocks's password [Default is 123456]: ------------------------------- Shadowsocks's Password: 123456 ------------------------------- Please enter shadowsocks's port (1~65535) [Default is 33526]: ------------------------------- Shadowsocks's Port: 33526 ------------------------------- Please select shadowsocks's stream cipher 1) aes-256-gcm 2) aes-256-ctr 3) aes-256-cfb 4) chacha20-ietf-poly1305 5) chacha20-ietf 6) chacha20 7) rc4-md5 [Default is aes-256-gcm]:3 ------------------------------- Shadowsocks's Streamcipher: aes-256-cfb ------------------------------- Press Enter to continue...or Press Ctrl+C to cancel 安装过程耗时 2~5 分钟，完成后会来到下图界面： [Info] Congratulations, Shadowsocks has been installed successfully. ================================================= Server IP : 1.1.1.1 Server Port : 33526 Password : 123456 Encryption Method: aes-256-cfb ------------------------------------------------- ss://YWVzLTI1Ni1jZmI6TnVtYmVyMTQzMzIyM0AxNDkuMjguMTMyLjEzMzo5NTI2 ================================================= You can find the config's backup in /root/shadowsocks.txt. For more tutorials: https://www.banwagongzw.com & https://www.vultrcn.com 接下来需要安装锐速TCP加速软件，由于系统自带内核版本太高无法安装锐速，需要进行降级，复制命令进行操作： [root@vultr ~]# wget --no-check-certificate -O rskernel.sh https://raw.githubusercontent.com/uxh/shadowsocks_bash/master/rskernel.sh && bash rskernel.sh 回车后系统会自动下载脚本并执行更换内核命令，按图提示，我们可以看到当前系统为CentOS7，等待内核更换完毕后系统会自动重启并断开连接： [INFO] System OS is CentOS7. Processing... ------------------------------------------- Retrieving https://filedown.me/Linux/Kernel/kernel-3.10.0-229.1.2.el7.x86_64.rpm Preparing... ################################# [100%] Updating / installing... 1:kernel-3.10.0-229.1.2.el7 ################################# [100%] ------------------------------------------- [INFO] Success! Your server will reboot in 3s... [INFO] Success! Your server will reboot in 2s... [INFO] Success! Your server will reboot in 1s... [INFO] Reboot... 系统重启后，软件会断开连接，等待3分钟左右服务器即可重启完毕，我们重新连接服务器，按图提示，我们继续复制命令： [root@vultr ~]# yum install net-tools -y && wget --no-check-certificate -O appex.sh https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh && bash appex.sh install 回车后系统会自动下载脚本并执行，按图提示，我们直接回车继续即可： Local Time : 2020-01-12 [16:00:09] ====================================================== | serverSpeeder | | for Linux | |----------------------------------------------------| | -- By .Vicer | ====================================================== Preparatory work... Press Enter to Continue... Preparatory work... Press Enter to Continue... Archive: /tmp/appex.zip inflating: /tmp/appex/install.sh creating: /tmp/appex/apxfiles/ creating: /tmp/appex/apxfiles/bin/ inflating: /tmp/appex/apxfiles/bin/renewLic.sh inflating: /tmp/appex/apxfiles/bin/serverSpeeder.sh inflating: /tmp/appex/apxfiles/bin/setConfig.sh inflating: /tmp/appex/apxfiles/bin/showConfig.sh inflating: /tmp/appex/apxfiles/bin/update.sh inflating: /tmp/appex/apxfiles/bin/utils.sh creating: /tmp/appex/apxfiles/etc/ inflating: /tmp/appex/apxfiles/etc/config Lic generate success! Installation done! 回车继续后系统会自动安装锐速，同时会先后要求我们设置锐速的三项信息，按图提示，我们每次都直接回车继续即可： ---- You are about to be asked to enter information that will be used by ServerSpeeder, there are several fields and you can leave them blank, for all fields there will be a default value. ---- Accelerate VPN (PPTP,L2TP,etc.)? [n]: Auto load ServerSpeeder on linux start-up? [y]: /etc/centos-release:CentOS Linux release 7.7.1908 (Core) /etc/os-release:NAME=\"CentOS Linux\" /etc/os-release:PRETTY_NAME=\"CentOS Linux 7 (Core)\" /etc/os-release:CENTOS_MANTISBT_PROJECT=\"CentOS-7\" /etc/redhat-release:CentOS Linux release 7.7.1908 (Core) /etc/system-release:CentOS Linux release 7.7.1908 (Core) Run ServerSpeeder now? [y]: 设置完三项信息完成后，系统会完成锐速安装并输出锐速的运行状态，按图提示，当出现红框内信息时说明锐速已完成安装并开机自启动： (license 628A71EDC5706E97151885d3) [Running Status] ServerSpeeder is running! version 3.11.20.10 [License Information] License 628A71EDC5706E97 (valid on current device) MaxSession unlimited MaxTcpAccSession unlimited MaxBandwidth(kbps) 1024000 ExpireDate 2035-12-31 在使用的过程中如果需要修改相关的配置信息，请使用下面的命令： 附一、修改Shadowsocks的配置信息 如果你以后需要修改Shadowsocks的配置（比如密码、端口或者加密），可以运行下列命令： 中文版：bash shadowsocks-libev_CN.sh 英文版：bash shadowsocks-libev.sh 然后选择第 8 项：修改Shadowsocks配置即可重新设置Shadowsocks的密码、端口以及加密方式。 附二、卸载Shadowsocks服务 如果你以后需要卸载Shadowsocks服务，可以运行下列命令： 中文版：bash shadowsocks-libev_CN.sh 英文版：bash shadowsocks-libev.sh 然后选择第 2 项：卸载Shadowsocks服务即可从服务器中卸载掉Shadowsocks服务。 小飞机下载 安装完成后，需要在我们需要科学上网的设备上安装相应软件来连接，下载请参考《电脑装机软件合集》里的 Shadowsocks小飞机，安装后使用。 "},"pleasure/crawler_web.html":{"url":"pleasure/crawler_web.html","title":"如何扒取整站内容","keywords":"","body":"如何扒取整站内容 刚看到一个很棒的资料站，想把里面的内容下载下来，嫌弃复制粘贴的方式太麻烦，于是写了个爬虫脚本去抓取，由于网站设置了反爬策略，不成功。 苦思冥想，wget 命令解决。 wget 可以以递归的方式下载整站，并可以将下载的页面中的链接转换为本地链接，加上相关参数后就可以变成功能强大的下载工具。 wget -r -p -np -k 网址 -r, –recursive（递归） specify recursive download.（指定递归下载） -k, –convert-links（转换链接） make links in downloaded HTML point to local files.（将下载的HTML页面中的链接转换为相对链接即本地链接） -p, –page-requisites（页面必需元素） get all images, etc. needed to display HTML page.（下载所有的图片等页面显示所需的内容） -np, –no-parent（不追溯至父级） don’t ascend to the parent directory. 另外断点续传用-nc参数 日志 用-o参数 随便选一个网站进行试验： [root@iZbp131uq20xx1y0zvhsskZ ~]# wget -r -p -np -k https://www.baidu.com --2020-01-13 17:47:12-- https://www.baidu.com/ Resolving www.baidu.com (www.baidu.com)... 180.101.49.11, 180.101.49.12 Connecting to www.baidu.com (www.baidu.com)|180.101.49.11|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 2443 (2.4K) [text/html] Saving to: ‘www.baidu.com/index.html’ 100%[=======================================================================================>] 2,443 --.-K/s in 0s 2020-01-13 17:47:12 (787 MB/s) - ‘www.baidu.com/index.html’ saved [2443/2443] Loading robots.txt; please ignore errors. --2020-01-13 17:47:12-- https://www.baidu.com/robots.txt Reusing existing connection to www.baidu.com:443. HTTP request sent, awaiting response... 200 OK Length: 2814 (2.7K) [text/plain] Saving to: ‘www.baidu.com/robots.txt’ 100%[=======================================================================================>] 2,814 --.-K/s in 0s 2020-01-13 17:47:12 (40.1 MB/s) - ‘www.baidu.com/robots.txt’ saved [2814/2814] Loading robots.txt; please ignore errors. --2020-01-13 17:47:12-- http://www.baidu.com/robots.txt Connecting to www.baidu.com (www.baidu.com)|180.101.49.11|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 2814 (2.7K) [text/plain] Saving to: ‘www.baidu.com/robots.txt’ 100%[=======================================================================================>] 2,814 --.-K/s in 0s 2020-01-13 17:47:12 (619 MB/s) - ‘www.baidu.com/robots.txt’ saved [2814/2814] FINISHED --2020-01-13 17:47:12-- Total wall clock time: 0.1s Downloaded: 3 files, 7.9K in 0s (104 MB/s) Converting www.baidu.com/index.html... 0-4 Converted 1 files in 0 seconds. 执行完成后，目录下会出现一个新文件夹，里面包含下载内容： [root@iZbp131uq20xx1y0zvhsskZ ~]# ll total 4 drwxr-xr-x 2 root root 4096 Jan 13 17:47 www.baidu.com 将文件打包下载即可： tar -cvf log.tar 1.log # 仅打包不压缩 tar -zcvf log.tar.gz 1.log # 打包后以 gzip 压缩 tar -jcvf log.tar.bz2 1.log # 打包后，以 bzip2 压缩 "},"python/data_analysis/numpy.html":{"url":"python/data_analysis/numpy.html","title":"Numpy介绍","keywords":"","body":"Numpy介绍 为什么会有Numpy Python中用列表(list)保存一组值，可以用来当作数组使用，不过由于列表的元素可以是任何对象，因此列表中所保存的是对象的指针。这样为了保存一个简单的[1,2,3]，需要有3个指针和三个整数对象。对于数值运算来说这种结构显然比较浪费内存和CPU计算时间。 此外Python还提供了一个array模块，array对象和列表不同，它直接保存数值，和C语言的一维数组比较类似。但是由于它不支持多维，也没有各种运算函数，因此也不适合做数值运算。 所以Numpy就这么登场了，NumPy是Python的一种开源的数值计算扩展。这种工具可用来存储和处理大型矩阵，比Python自身的嵌套列表（nested list structure)结构要高效的多（该结构也可以用来表示矩阵（matrix））。 NumPy的主要对象是同种元素的多维数组。这是一个所有的元素都是一种类型、通过一个正整数元组索引的元素表格(通常是元素是数字)。在NumPy中维度(dimensions)叫做轴(axes)，轴的个数叫做秩(rank)。 Numpy的所有的函数docs，点击查看。 Numpy的核心array对象以及创建array的方法 array对象的背景 Numpy的核心数据结构，就叫做array就是数组，array对象可以是一维数组，也可以是多维数组。 Python的List也可以实现相同的功能，但是array比List的优点在于性能好、包含数组元数据信息、大量的便捷函数。 Numpy成为事实上的Scipy、Pandas、Scikit-Learn、Tensorflow、PaddlePaddle等框架的“通用底层语言”。 Numpy的array和Python的List的一个区别，是它元素必须都是同一种数据类型，比如都是数字int类型，这也是Numpy高性能的一个原因。 创建array的方法 从Python的列表List和嵌套列表创建array。 # 创建一个一维数组，也就是Python的单元素List x = np.array([1, 2, 3, 4, 5, 6, 7, 8]) print(x) # 创建一个二维数组，也就是Python的嵌套List x = np.array( [ [1, 2, 3, 4], [5, 6, 7, 8] ] ) print(x) 使用预定函数arange、ones/ones_like、zeros/zeros_like、empty/empty_like、full/full_like、eye等函数创建。 # 使用arange创建数字序列 # arange([start,] stop[, step,], dtype=None) x = np.arange(10) print(x) y = np.arange(2, 10, 2) print(y) # 使用ones创建全是1的数组 # np.ones(shape, dtype=None, order='C') # shape : int or tuple of ints Shape of the new array, e.g., (2, 3) or 2. x = np.ones(10) print(x) y = np.ones((2, 3)) print(y) # 使用ones_like创建形状相同的数组 # ones_like(a, dtype=float, order='C') print(np.ones_like(x)) print(np.ones_like(X)) # 使用zeros创建全是0的数组 # np.zeros(shape, dtype=None, order='C') print(np.zeros(10)) print(np.zeros((3, 4))) # 使用zeros_like创建形状相同的数组 # np.zeros_like(a, dtype=None) print(np.zeros_like(x)) print(np.zeros_like(X)) # 使用empty创建全是0的数组 # empty(shape, dtype=float, order='C') # 注意：数据是未初始化的，里面的值可能是随机值不要用 print(np.empty(10)) print(np.empty((3, 4))) # 使用empty_like创建形状相同的数组 # empty_like(prototype, dtype=None) print(np.empty_like(x)) print(np.empty_like(X)) # 使用full创建指定值的数组 # np.full(shape, fill_value, dtype=None, order='C') print(np.full(10, 666)) print(np.full((3, 4), 888)) # 使用full_like创建形状相同的数组¶ # np.full_like(a, fill_value, dtype=None) print(np.full_like(x, 666)) print(np.full_like(X, 666)) 生成随机数的np.random模块构建。 # 使用random模块生成随机数的数组 # randn(d0, d1, ..., dn) print(np.random.randn()) print(np.random.randn(3)) print(np.random.randn(3, 4)) print(np.random.randn(3, 3, 4)) array本身的属性 shape：返回一个元组，表示array的维度。 # 创建一个一维数组，也就是Python的单元素List x = np.array([1, 2, 3, 4, 5, 6, 7, 8]) print(x) # 创建一个二维数组，也就是Python的嵌套List X = np.array( [ [1, 2, 3, 4], [5, 6, 7, 8] ] ) print(X) print(x.shape) print(X.shape) # (8,) # (2, 4) ndim：一个数字，表示array的维度的数目。 print(x.ndim) print(X.ndim) # 1 # 2 size：一个数字，表示array中所有数据元素的数目。 print(x.size) print(X.size) # 8 # 8 dtype：array中元素的数据类型。 print(x.dtype) print(X.dtype) # int64 # int64 array本身支持的大量操作和函数 直接逐元素的加减乘除等算数操作。 A = np.arange(10).reshape(2, 5) print(A) print(A + 3) print(A * 2) print(A ** 2) 更好用的面向多维的数组索引。 求sum/mean等聚合函数。 线性代数函数，比如求解逆矩阵、求解方程组。 Numpy对数组按索引查询 import numpy as np x = np.arange(20) X = np.arange(20).reshape(4, 5) print(x) print(X) 基础索引 # 一维数组 # 和Python的List一样 print(x[2], x[5], x[-1]) print(x[2:4]) print(x[2:-1]) print(x[-3:]) # 二维数组 # 分别用行坐标、列坐标，实现行列筛选 print(X[0, 0]) print(X[-1, 2]) print(X[:-1]) # 筛选多行 print(X[:2, 2:4]) # 筛选多行，然后筛选多列 print(X[:, 2]) # 筛选所有行，然后筛选多列 # 注意：切片的修改会修改原来的数组 # 原因：Numpy经常要处理大数组，避免每次都复制 x[2:4] = 666 print(x) 神奇索引 # 其实就是：用整数数组进行的索引，叫神奇索引 # 一维数组 x = np.arange(10) print(x) print(x[[3, 4, 7]]) indexs = np.array([[0, 2], [1, 3]]) print(x[indexs]) # 二维数组 X = np.arange(20).reshape(4, 5) print(X[[0, 2]]) # 筛选多行，列可以省略 print(X[[0, 2], :]) print(X[:, [0, 2, 3]]) # 筛选多列，行不能省略 print(X[[0, 2, 3], [1, 3, 4]]) # 同时指定行列-列表 布尔索引 # 一维数组 x = np.arange(10) print(x > 5) print(x[x > 5]) # 二维数组 X = np.arange(20).reshape(4, 5) print(X > 5) # X>5的boolean数组，既有行，又有列 print(X[X > 5]) print(X[X[:, 3] > 5]) Numpy常用random随机函数 官方文档地址。 rand(d0, d1, ..., dn)：返回数据在[0, 1)之间，具有均匀分布 print(np.random.rand(5)) print(np.random.rand(3, 4)) print(np.random.rand(2, 3, 4)) randn(d0, d1, ..., dn)：返回数据具有标准正态分布（均值0，方差1） print(np.random.randn(5)) print(np.random.randn(3, 4)) print(np.random.randn(2, 3, 4)) randint(low[, high, size, dtype])：生成随机整数，包含low，不包含high，如果high不指定，则从[0, low)中生成数字 print(np.random.randint(3)) print(np.random.randint(1, 10)) print(np.random.randint(10, 30, size=(5,))) print(np.random.randint(10, 30, size=(2, 3, 4))) random([size])：生成[0.0, 1.0)的随机数 print(np.random.random(5)) print(np.random.random(size=(3, 4))) print(np.random.random(size=(2, 3, 4))) choice(a[, size, replace, p])：a是一维数组，从它里面生成随机结果 print(np.random.choice(5, 3)) # 这时候，a是数字，则从range(5)中生成，size为3 print(np.random.choice(5, (2, 3))) print(np.random.choice([2, 3, 6, 7, 9], 3)) # 这时候，a是数组，从里面随机取出数字 print(np.random.choice([2, 3, 6, 7, 9], (2, 3))) shuffle(x)：把一个数组x进行随机排列 # 一维数组 a = np.arange(10) np.random.shuffle(a) print(a) # 如果是多维数组，则只会在第一维度上随机 A = np.arange(20).reshape(4, 5) np.random.shuffle(A) print(A) permutation(x)：把一个数组x进行随机排列，或者数字的全排列 print(np.random.permutation(10)) # 这时候，生成range(10)的随机排列 print(np.random.permutation(np.arange(9).reshape((3, 3)))) # 这时候，在第一维度进行打散 # 注意，这里不会更改原来的arr，会返回一个新的copy normal([loc, scale, size])：按照平均值loc和方差scale生成高斯分布的数字 print(np.random.normal(1, 10, 10)) print(np.random.normal(1, 10, (3, 4))) uniform([low, high, size])：在[low, high)之间生成均匀分布的数字 print(np.random.uniform(1, 10, 10)) print(np.random.uniform(1, 10, (3, 4))) Numpy的数学统计函数 Numpy有哪些数学统计函数 函数名 说明 np.sum 所有元素的和 np.prod 所有元素的乘积 np.cumsum 元素的累积加和 np.cumprod 元素的累积乘积 np.min 最小值 np.max 最大值 np.percentile 0-100百分位数 np.quantile 0-1分位数 np.median 中位数 np.average 加权平均，参数可以指定weights np.mean 平均值 np.std 标准差 np.var 方差 arr = np.arange(12).reshape(3, 4) print(np.sum(arr)) # 所有元素的和 print(np.prod(arr)) # 所有元素的乘积 print(np.cumsum(arr)) # 元素的累积加和 print(np.cumprod(arr)) # 元素的累积乘积 print(np.min(arr)) # 最小值 print(np.max(arr)) # 最大值 print(np.percentile(arr, [25, 50, 75])) # 0-100百分位数 print(np.quantile(arr, [0.25, 0.5, 0.75])) # 0-1分位数 print(np.median(arr)) # 中位数 weights = np.random.rand(*arr.shape) # 加权平均，参数可以指定weights np.average(arr, weights=weights) # weights的shape需要和arr一样 print(np.mean(arr)) # 平均值 print(np.std(arr)) # 标准差 print(np.var(arr)) # 方差 怎样实现按不同的axis计算 以上函数，都有一个参数叫做axis用于指定计算轴为行还是列，如果不指定，那么会计算所有元素的结果。 axis=0代表行、axis=1代表列，对于sum/mean/media等聚合函数： axis=0代表把行消解掉，axis=1代表把列消解掉。 arr = np.arange(20).reshape(4, 5) print(arr) print(arr.sum(axis=0)) print(arr.sum(axis=1)) Numpy计算数组中满足条件元素个数 arr = np.random.randint(1, 10000, size=int(1e8)) print(arr[:10]) # 计算下结果，用于对比是否准确 print(arr[arr > 5000].size) Numpy怎样给数组增加一个维度 背景 很多数据计算都是二维或三维的，对于一维的数据输入为了形状匹配，经常需升维变成二维。 需要 在不改变数据的情况下，添加数组维度；（注意观察这个例子，维度变了，但数据不变） 原始数组：一维数组arr=[1,2,3,4]，其shape是(4,)，取值分别为arr[0],arr[1],arr[2],arr[3]。 变形数组：二维数组arr[[1,2,3,4]]，其shape实(1,4), 取值分别为a[0,0],a[0,1],a[0,2],a[0,3]。 实操的3种方法 np.newaxis：关键字，使用索引的语法给数组添加维度。 # np.newaxis：关键字，使用索引的语法给数组添加维度 # 注意：np.newaxis其实就是None的别名 # print(np.newaxis is None) arr = np.arange(5) # 给一维向量添加一个行维度 print(arr[np.newaxis, :]) # 给一维向量添加一个列维度 print(arr[:, np.newaxis]) np.expand_dims(arr,axis)：方法，和np.newaxis实现一样的功能，给arr在axis位置添加维度。 arr = np.arange(5) # np.expand_dims方法实现的效果，和np.newaxis关键字是一模一样的 # 给一维数组添加一个行维度 print(np.expand_dims(arr, axis=0)) # 给一维数组添加一个列维度 print(np.expand_dims(arr, axis=1)) np.reshape(a, newshape)：方法，给一个维度设置为1完成升维。 arr = np.arange(5) # 给一维数组添加一个行维度 print(np.reshape(arr, (1, 5))) print(np.reshape(arr, (1, -1))) # -1表示让Numpy自己计算有几列 # 给一维数组添加一个列维度 print(np.reshape(arr, (-1, 1))) # -1表示让Numpy自己计算有几行 Numpy重要的数组合并操作 背景：在给机器学习准备数据的过程中，经常需要进行不同来源的数据合并的操作。 两类场景： 给已有的数据添加多行，比如增添一些样本数据进去； 给已有的数据添加多列，比如增添一些特征进去； 以下操作均可以实现数组合并： np.concatenate(array_list, axis=0/1）：沿着指定axis进行数组的合并。 np.vstack或者np.row_stack(array_list)：垂直vertically、按行row wise进行数据合并。 np.hstack或者np.column_stack(array_list)：水平horizontally、按列column wise进行数据合并。 # 给数据添加新的多行 a = np.arange(6).reshape(2, 3) b = np.random.randint(10, 20, size=(4, 3)) print(np.concatenate([a, b])) print(np.vstack([a, b])) print(np.row_stack([a, b])) # 给数据添加新的多列 A = np.arange(12).reshape(3, 4) B = np.random.randint(10, 20, size=(3, 2)) print(np.concatenate([A, B], axis=1)) print(np.hstack([A, B])) print(np.column_stack([A, B])) Numpy怎么对数组进行排序 Numpy给数组排序有三种方法： numpy.sort：返回排序后数组的拷贝。 array.sort：原地排序数组而不是返回拷贝。 numpy.argsort：间接排序，返回的是排序后的数字索引。 三种方法都支持一个参数kind，可以是以下一个值： quicksort：默认值，快速排序，平均O(nlogn)，不稳定情况。 mergesort：归并排序，平均O(nlogn)，稳定排序。 heapsort：堆排序，平均O(nlogn)，不稳定排序。 stable：稳定排序。 arr = np.array([1, 2, 5, 3, 8, 6, 9, 3]) print(np.sort(arr)) # 返回排序后的拷贝数组 arr.sort() # 原地排序 print(arr) indices = np.argsort(arr) # 获得排序元素对应的索引数字列表 print(arr[indices]) # 直接获取对应的数据列表 Numpy怎么实现数组的乘法 按照两个相乘数组的维度的不同，分为以下几种乘法： 数字与一维/二维数组相乘。 一维数组与一维数组相乘。 一维数组与二维数组相乘。 二维数据与二维数组相乘。 乘法函数 *符号或者np.multily：逐元素乘法，对应位置的元素相乘，要求shape相同。 @符号或者np.matmul：矩阵乘法，形状要求满足(n, k),(k, m)—>（n, m）。 np.dot：点积乘法（也叫内积或数量积），两个向量a=[a1, a2,···，an]和b=[b1, b2, ···, bn]的点积定义为：a·b = a1b1 + a2b2 + ··· + anbn。 # 数字与一维/二维数组相乘 A = np.arange(10) # 一维数组 print(A * 0.5) B = np.arange(12).reshape(3, 4) print(B * 0.5) # 一维数组与一维数组相乘 A = np.arange(1, 11) B = np.arange(11, 21) print(np.multiply(A, B)) # 逐元素乘法 print(A * B) print(np.matmul(A, B)) print(A @ B) print(np.dot(A, B)) # 一维数组与二维数组相乘 A = np.arange(1, 5) B = np.arange(1, 21).reshape(5, 4) print(A@B) "}}